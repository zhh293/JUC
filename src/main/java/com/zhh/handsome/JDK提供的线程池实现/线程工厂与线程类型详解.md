# 线程工厂与线程类型详解（JDK8 → JDK21 虚拟线程）

## 概览
- 目标：系统讲清 Java 中“如何创建线程”的工厂与现成线程类型，从 JDK8 的 `ThreadFactory` 到 JDK21 的虚拟线程（Project Loom）。
- 涵盖：`ThreadFactory` 接口、`Executors` 提供的默认/特权工厂、`ForkJoinPool` 的工厂、常见线程池如何使用工厂、JDK21 的虚拟线程与相关工厂、最佳实践与避坑。

## ThreadFactory 接口（JDK8）
- 定义：`java.util.concurrent.ThreadFactory`，唯一方法 `Thread newThread(Runnable r)`。
- 作用：统一线程创建策略（命名、守护/非守护、优先级、异常处理、线程组），与线程池解耦。
- 常见使用：在线程池构造中传入自定义工厂，以便定位问题与统一规范。

```java
public interface ThreadFactory {
  Thread newThread(Runnable r);
}
```

## JDK 提供的线程工厂（JDK8）
- `Executors.defaultThreadFactory()`
  - 行为：创建“非守护（daemon=false）、优先级 NORM（5）”的普通平台线程，命名 `pool-N-thread-M`，归属当前或安全管理器指定的 `ThreadGroup`。
  - 应用：`newFixedThreadPool/newCachedThreadPool/newSingleThreadExecutor` 的默认工厂。
- `Executors.privilegedThreadFactory()`
  - 行为：与默认工厂类似，但在线程创建时继承调用方的 `AccessControlContext` 与 `contextClassLoader`，用于受限安全环境或容器化场景。
  - 应用：需要权限隔离或特定类加载器语义的服务。

示例：自定义命名 + 异常处理
```java
class NamedThreadFactory implements ThreadFactory {
  private final AtomicInteger idx = new AtomicInteger(1);
  private final String prefix;
  NamedThreadFactory(String prefix) { this.prefix = prefix; }
  @Override public Thread newThread(Runnable r) {
    Thread t = new Thread(r, prefix + idx.getAndIncrement());
    t.setDaemon(false);
    t.setPriority(Thread.NORM_PRIORITY);
    t.setUncaughtExceptionHandler((th, ex) -> {
      System.err.println("Uncaught in " + th.getName() + ": " + ex);
    });
    return t;
  }
}
```

在线程池中使用：
```java
ExecutorService pool = new ThreadPoolExecutor(
  4, 8, 30, TimeUnit.SECONDS,
  new ArrayBlockingQueue<>(100),
  new NamedThreadFactory("order-pool-"),
  new ThreadPoolExecutor.AbortPolicy()
);
```

## ForkJoinPool 的线程工厂（JDK8）
- 接口：`ForkJoinPool.ForkJoinWorkerThreadFactory`
  - 方法：`ForkJoinWorkerThread newThread(ForkJoinPool pool)`
- 默认实现：`ForkJoinPool.DefaultForkJoinWorkerThreadFactory`
  - 作用：为 `ForkJoinPool` 创建 `ForkJoinWorkerThread`（工作窃取调度），命名类似 `ForkJoinPool.commonPool-worker-N`。
- 关联：`CompletableFuture` 默认使用 `ForkJoinPool.commonPool()`；如需控制线程命名/属性/隔离，传入自定义 `Executor`。

自定义工厂示例：
```java
ForkJoinPool.ForkJoinWorkerThreadFactory factory = pool -> {
  ForkJoinWorkerThread t = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
  t.setName("fj-analytics-" + t.getPoolIndex());
  return t;
};
ForkJoinPool fj = new ForkJoinPool(Runtime.getRuntime().availableProcessors(), factory, null, false);
```

## 常见线程池与工厂（JDK8）
- `ThreadPoolExecutor`：通过构造函数传入 `ThreadFactory`。
- `ScheduledThreadPoolExecutor`：同样支持自定义工厂，任务为定时/周期调度。
- `Executors` 快捷方法（不推荐生产直接使用）：
  - `newFixedThreadPool`、`newSingleThreadExecutor`：默认使用 `defaultThreadFactory`；工作队列默认无界，可能 OOM。
  - `newCachedThreadPool`：最大线程数近似无限，可能 OOM；默认工厂同上。

## JDK21 虚拟线程（Project Loom）
- 概念：由 JVM 管理、轻量级的线程，每个任务一个虚拟线程；阻塞操作会“停放（park）”虚拟线程并释放载体（carrier）平台线程。
- 优势：海量并发（数量可达百万级）、以同步阻塞风格写代码、无需复杂回调；IO 阻塞不再占用昂贵的平台线程。
- 关键 API：
  - `Thread.ofVirtual()`：返回虚拟线程构建器；`ThreadFactory factory()` 可获得虚拟线程工厂。
  - `Thread.ofPlatform()`：平台线程构建器。
  - `Executors.newVirtualThreadPerTaskExecutor()`：为每个任务分配一个虚拟线程的执行器（自动关闭需 `try-with-resources`）。

示例：直接创建虚拟线程
```java
Thread vt = Thread.ofVirtual().name("vt-task-1").start(() -> {
  // 阻塞 IO、sleep 等不会占用平台线程
});
vt.join();
```

示例：虚拟线程工厂与线程池
```java
ThreadFactory vtf = Thread.ofVirtual().factory();
try (ExecutorService exec = Executors.newVirtualThreadPerTaskExecutor()) {
  exec.submit(() -> {/* IO/网络阻塞任务 */});
}
```

平台线程 vs 虚拟线程 构建器用法（JDK21）：
```java
Thread t1 = Thread.ofPlatform().name("platform-1").unstarted(() -> {});
Thread t2 = Thread.ofVirtual().name("virtual-1").start(() -> {});
```

虚拟线程注意点：
- “Pinned” 情况：在进入某些不可挂载的临界区（如长时间持有 `synchronized`、JNI 调用等）时，虚拟线程可能被固定在载体线程上，阻塞会占用载体资源；避免长时间阻塞在 `synchronized`，优先使用 `Lock`/`Semaphore`。
- 资源配额：尽管虚拟线程非常多，但任务/连接/内存都是瓶颈，依旧需要限流与背压（如使用连接池、限速器）。
- 调度与诊断：虚拟线程栈可在 `jcmd`/`jstack` 等工具中查看；命名与分组仍然重要。

## 选择与迁移建议
- IO 密集场景：优先采用虚拟线程，简化同步代码，提升吞吐；改造点是删除多余的异步框架层（如回调、复杂 Reactor 流），保留显式限流。
- 计算密集场景：仍然以平台线程 + 合理大小的池为主；配合 `ForkJoinPool`/并行流更合适。
- 框架集成：
  - Spring：从 JDK21 起可将 `TaskExecutor` 或 Web 层执行器替换为虚拟线程执行器；结合控制器/服务层同步代码简化开发。
  - 数据库/网络：阻塞驱动（JDBC/HTTP 客户端）更易受益；使用异步驱动也能运行，但意义偏小。

## 常见“现成线程类”速览
- `java.lang.Thread`：平台线程与虚拟线程的统一入口（JDK21 增 builder）。
- `java.util.concurrent.ForkJoinWorkerThread`：`ForkJoinPool` 的工作线程类型。
- 虚拟线程（`VirtualThread`，内部实现类）：用户通过 `Thread.ofVirtual()` 使用。

## 工厂与线程命名准则
- 命名规范：`{service}-{pool}-thread-{index}`；虚拟线程：`vt-{service}-{index}`。
- 守护属性：线程池中的工作线程通常非守护，确保任务生命周期明确；虚拟线程默认守护属性由构建器控制。
- 异常处理：统一 `UncaughtExceptionHandler`，记录堆栈与关键上下文。
- 可观测性：在工厂中计数/打点，配合监控（活跃线程、创建速率、拒绝次数）。

## 代码范式：跨版本统一工厂
```java
interface Naming {
  static ThreadFactory platformFactory(String prefix) {
    return r -> {
      Thread t = Thread.ofPlatform().name(prefix + UUID.randomUUID()).unstarted(r);
      t.setUncaughtExceptionHandler((th, ex) -> System.err.println(ex));
      return t;
    };
  }
  static ThreadFactory virtualFactory(String prefix) {
    ThreadFactory f = Thread.ofVirtual().factory();
    return r -> {
      Thread t = f.newThread(r);
      t.setName(prefix + t.getName());
      return t;
    };
  }
}
```

## 总结
- JDK8：以 `ThreadFactory` 统一线程创建策略，默认工厂满足多数需求，但生产建议自定义命名与异常处理。
- JDK21：虚拟线程显著提升 IO 并发能力与开发体验；结合每任务虚拟线程执行器，在保持同步风格的同时实现高并发。
- 选择原则：以任务模型为核心；IO 阻塞→虚拟线程，计算密集→平台线程 + 小池，始终保留限流与监控。
