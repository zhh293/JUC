package com.zhh.handsome.JDK提供的线程池实现;

public class 底层原理 {





    /*ThreadPoolExecutor 底层核心原理（简洁版）
    ThreadPoolExecutor 的底层设计核心是「并发安全的状态管理」+「线程复用机制」，所有复杂逻辑都是围绕这两个核心展开的，以下是关键原理拆解：
            1. 核心控制变量：ctl 原子整数（状态 + 线程数二合一）
    ThreadPoolExecutor 用一个 原子整数 ctl 来同时管理两件事（避免多变量并发同步的开销）：
    高 3 位：存储「线程池状态」（RUNNING/SHUTDOWN/STOP/TIDYING/TERMINATED）；
    低 29 位：存储「当前工作线程数」。
    通俗比喻：相当于餐厅的「前台总控面板」—— 左边显示餐厅营业状态（正常营业 / 停止接客 / 关门），右边显示当前在岗的服务员数量，面板的修改是「原子的」（要么改完，要么没改，不会出现改到一半被打断的情况）。
    核心作用：通过 CAS（Compare and Swap，比较并交换）操作保证多线程下「状态 + 线程数」修改的并发安全，避免计数错误、状态混乱。
            2. 线程复用的核心：Worker 类
    线程池之所以能「复用线程」，核心是封装了 Worker 类（实现了 Runnable），每个 Worker 对应一个工作线程：
    Worker 内部持有一个 Thread 对象（真正的执行线程）；
    Worker 的 run() 方法会调用 runWorker() 核心方法，这个方法是一个无限循环：
    先执行 Worker 初始化时绑定的第一个任务；
    任务执行完后，循环调用 workQueue.take()（阻塞方法）从工作队列取新任务；
    只要能取到任务就继续执行，直到线程被中断（比如线程池关闭、非核心线程空闲超时）。
    通俗比喻：服务员（Worker）入职后，不会只服务一个客人就下班，而是站在候客区（workQueue）旁，不断接过新的客人订单（任务），直到餐厅通知下班（线程中断 / 池关闭）—— 这就是「线程复用」的底层逻辑，线程不销毁，只是循环取任务执行。
            3. 任务提交的底层逻辑（execute() 方法核心）
    你调用 execute() 提交任务时，底层不是简单的 “丢进队列”，而是一套并发安全的判断逻辑：
    先通过 ctl 检查线程池状态（是否为 RUNNING），若不是则直接拒绝任务；
    用 CAS 尝试增加工作线程数，若当前线程数 < 核心线程数，则创建新 Worker（核心线程）执行任务；
    若核心线程数已满，尝试将任务放入 workQueue（队列满则入队失败）；
    入队失败后，再用 CAS 尝试增加线程数（创建非核心线程），若当前线程数 < 最大线程数，则创建新 Worker（非核心线程）执行任务；
    若创建非核心线程也失败（线程数达上限），执行拒绝策略。
    核心保障：全程用 CAS 代替锁，减少线程阻塞开销，保证高并发下的效率和安全。
            4. 线程销毁的底层触发
    核心线程：默认不会销毁，因为 workQueue.take() 是「无超时阻塞」—— 没任务时线程会一直阻塞在取任务的步骤，不会退出循环；若设置 allowCoreThreadTimeOut=true，则核心线程会用 poll(timeout) 取任务，超时后退出循环，线程销毁。
    非核心线程：空闲时用 poll(keepAliveTime) 取任务，超时取不到则退出循环，Worker 被回收，线程销毁。
    总结（底层原理核心点）
    ctl 原子变量：是线程池的 “总控中心”，同时管理状态和线程数，通过 CAS 保证并发安全；
    Worker 类：是线程复用的核心，通过循环取任务的逻辑，让线程不随单个任务结束而销毁；
    无锁并发：核心逻辑（如线程数增减、任务提交）依赖 CAS 而非传统锁，保证高并发效率。
    这就是 ThreadPoolExecutor 最核心的底层逻辑，不用纠结源码的每一行，理解这 3 个关键点，就能明白它 “为什么能高效、安全地管理线程”。*/












}
