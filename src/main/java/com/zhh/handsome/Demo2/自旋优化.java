package com.zhh.handsome.Demo2;

public class 自旋优化 {

    /*自旋优化是 Java 虚拟机（JVM）为了减少线程阻塞 / 唤醒开销而设计的一种并发优化手段，核心思想是：当线程竞争锁失败时，不立即进入阻塞状态，而是原地 “循环等待” 一段时间（自旋），看看持有锁的线程是否会很快释放锁。这种 “再等等” 的策略，能避免频繁的线程切换（阻塞 / 唤醒）带来的性能损耗。
    为什么需要自旋优化？
    要理解自旋的价值，先得知道 “线程阻塞” 的成本有多高：当线程竞争锁失败时，如果直接进入阻塞状态，需要从 “用户态” 切换到 “操作系统内核态”（因为线程调度是内核负责的），这个过程会涉及：
    保存线程的上下文（寄存器、程序计数器等状态）；
    从 CPU 调度队列中移除该线程；
    操作系统重新调度其他线程运行。
    而当持有锁的线程释放锁后，阻塞的线程又需要从 “内核态” 切回 “用户态”，重新加载上下文，再次竞争锁。这种 “用户态↔内核态” 的切换开销很大（通常是微秒级，对高频竞争场景影响显著）。
    如果持有锁的线程释放锁的速度很快（比如同步块里的代码执行时间极短），那么 “阻塞等待” 的成本可能远高于 “原地等一会儿” 的成本 —— 这就是自旋优化的出发点：用短暂的 CPU 空转，换线程切换的高开销。
    自旋优化的基本流程
    以 “线程 A 持有锁，线程 B 竞争锁” 为例，自旋的过程如下：
    线程 B 尝试获取锁，发现锁已被线程 A 持有；
    线程 B 不立即阻塞，而是进入 “自旋状态”：执行一段无意义的循环（比如for (int i=0; i<N; i++) {}）；
    自旋期间，线程 B 会持续检查锁是否被释放（比如不断读取对象头的 Mark Word）；
    若自旋结束前，线程 A 释放了锁，线程 B 直接获取锁，进入同步块；
    若自旋结束后，锁仍未释放，线程 B 则放弃自旋，进入阻塞状态，等待被唤醒。
    自旋的关键细节：次数控制
    自旋不能无限进行 —— 如果持有锁的线程执行时间很长（比如同步块里有复杂逻辑），自旋就会变成 “无效的 CPU 空转”，反而浪费资源。因此 JVM 需要控制自旋的 “次数上限”。
    根据 JDK 版本的演进，自旋次数的控制有两种方式：
            1. 固定次数自旋（JDK 1.6 之前）
    早期 JVM 采用 “固定次数” 的自旋策略，默认自旋次数为 10 次（可通过-XX:PreBlockSpin参数调整）。比如设置-XX:PreBlockSpin=5，则线程最多自旋 5 次，无论结果如何，到期后要么获取锁，要么进入阻塞。
            2. 自适应自旋（JDK 1.6 及之后）
    固定次数的缺陷很明显：无法适应不同场景（有的锁释放快，有的释放慢）。因此 JDK 1.6 引入了 “自适应自旋”，核心逻辑是：自旋次数不再固定，而是根据 “历史竞争情况” 动态调整。
    具体规则：
    如果 “线程 B 之前自旋等待线程 A 释放锁时，多次成功获取到锁”（说明 A 释放锁很快），JVM 会认为这次自旋也可能成功，会增加自旋次数（比如从 10 次增加到 20 次）；
    如果 “线程 B 之前自旋等待时，几乎每次都失败”（说明 A 释放锁很慢），JVM 会认为自旋意义不大，会减少自旋次数甚至直接省略自旋，让线程 B 直接进入阻塞；
    自适应自旋还会结合 “锁的持有者身份” 判断：如果上次持有锁的线程是当前线程，这次自旋成功的概率更高（可能是锁重入场景），会适当增加自旋次数。
    自旋优化的适用场景
    自旋不是万能的，它只适合 **“锁持有时间短、竞争不激烈”** 的场景：
    锁持有时间短：比如同步块里只有几行简单代码（如赋值、判断），持有锁的线程很快会释放，自旋能大概率 “等” 到锁；
    竞争不激烈：如果大量线程同时竞争同一把锁（比如 10 个线程抢 1 把锁），即使每个线程自旋次数很少，整体的 CPU 空转成本也会很高（10 个线程各自旋 10 次，就是 100 次空转），此时自旋反而低效。
    自旋与锁机制的结合
    在 Java 的锁升级流程中，自旋通常配合轻量级锁和重量级锁使用：
    轻量级锁竞争时：线程竞争轻量级锁失败后，会先自旋几次，若自旋成功则获取锁；若失败，则触发锁膨胀为重量级锁。
    重量级锁竞争时：线程尝试获取重量级锁（ObjectMonitor）失败后，不会立即进入阻塞队列，而是先自旋尝试（通过TryLock操作），若失败再进入队列阻塞。
    总结：自旋优化的本质
    自旋优化是一种 “时间换空间” 的权衡策略：
    用短暂的 CPU 空转（自旋），避免线程阻塞 / 唤醒的高开销（内核态切换）；
    通过 “自适应次数” 动态调整，让自旋在 “锁释放快、竞争少” 的场景下发挥最大价值；
    核心目标是：在并发竞争中，平衡 CPU 资源消耗和线程调度开销，提升整体性能。*/








}
