package com.zhh.handsome.Demo2;

public class Monitor2 {

   /*


   我们用一个生活场景来类比：假设你有一个共享工具（比如打印机），多人可能要用，synchronized 就相当于 “管理这个工具的使用规则”。JVM 设计 “锁升级”，本质是为了在 “没人抢”“少人抢”“多人抢疯了” 这三种场景下，用最省力气的方式管理工具 —— 就像超市结账，人少的时候自助结账（快但扛不住人多），人多的时候开人工柜台（慢但稳）。
    先明确核心目标：为什么要搞 “锁”？
    本质是为了保证 “同一时间只有一个线程能执行同步代码块”（即 “互斥性”）。但 “保证互斥” 的代价有高有低，JVM 会根据 “竞争激烈程度” 选代价最低的方式 —— 这就是锁升级的逻辑。
            1. 无锁状态：工具没人用，随便拿
    场景：对象刚创建，还没被任何线程当作 synchronized 的锁对象（或者同步代码块还没被执行过）。Mark Word 存啥：对象的哈希码（相当于工具的唯一编号）、分代年龄（JVM 垃圾回收用的，暂时不用管）、锁标志位（01）。
    举例：你新买了一台打印机，放在办公室，还没人用过。这时候谁想用直接拿，不需要登记、不需要排队 —— 因为根本没人抢，没必要搞复杂规则。
    为什么叫 “无锁”：不是说没有锁，而是 “不需要启动任何同步机制”。就像工具没人抢时，自然不用 “锁” 来管理。
            2. 偏向锁：工具长期被一个人用，贴个他的名字
    场景：只有一个线程反复进入同步块（比如单线程程序，或者某个工具长期被一个人独占）。核心逻辑：“贴标签”—— 在对象头的 Mark Word 里记录这个线程的 ID，下次这个线程再来，直接放行，不用重新 “抢锁”。
    详细过程：
    第一次进入同步块：线程 A 发现对象是 “无锁状态”，就用 CAS 操作在 Mark Word 里 “贴” 上自己的线程 ID（同时把 “偏向标志” 设为 1，锁标志位还是 01，但表示 “偏向模式”）。这个过程叫 “偏向锁初始化”。
    后续再进入同步块：线程 A 一看 Mark Word 里的线程 ID 是自己，直接进入，连 CAS 都不用做 —— 相当于 “这是我的专属工具，不用检查，直接用”。
    退出同步块：线程 A 啥也不用做（不用清除线程 ID），因为它知道暂时没人抢，留着标签下次方便自己用。
    为什么不用 Monitor？
    Monitor 管理线程需要 “排队、阻塞” 等操作，这些操作依赖操作系统内核态，开销很大（后面会细说）。而偏向锁本质是 “假设只有一个线程用”，只需要在对象头里记个 ID，连 “加锁 / 解锁” 的过程都简化了 —— 就像你常用的工具，贴个自己名字，每次用不用跟别人打招呼，效率极高。
    什么时候会撤销偏向锁？
    如果突然来了另一个线程 B 想抢这个对象的锁（进入同步块），JVM 会先检查 Mark Word 里的线程 ID：
    如果线程 A 已经 “死了”（结束了），直接把偏向锁的线程 ID 改成线程 B 的，继续用偏向锁；
    如果线程 A 还活着，就会 “撤销偏向锁”，把对象状态改回 “无锁”，然后线程 A 和 B 开始竞争，升级为 “轻量级锁”。
            3. 轻量级锁：有少数人抢，大家轮流 “问问” 能不能用
    场景：有少量线程竞争（比如两个线程偶尔抢一下，但不频繁）。这时候偏向锁已经不够用了（因为有竞争），但又没到 “抢疯了” 的程度。核心逻辑：用 CAS 自旋（“反复询问”）代替 Monitor 的阻塞 —— 就像两个人抢打印机，一个人正在用，另一个人不离开，就在旁边问 “用完了吗？”“现在能给我用吗？”，而不是去排队（排队对应 Monitor 的阻塞，开销大）。
    详细过程：
    线程抢锁时：每个线程会在自己的栈帧里创建一个 “锁记录”（Lock Record），里面存着 “当前对象 Mark Word 的拷贝” 和 “指向对象的指针”。然后用 CAS 尝试把对象的 Mark Word 改成 “指向自己锁记录的指针”（锁标志位改为 00）。
    如果 CAS 成功：抢到锁，进入同步块；
    如果 CAS 失败：说明有其他线程正在用（比如线程 A 刚抢到），当前线程就开始 “自旋”（循环几次，再用 CAS 试）。
    线程释放锁时：用 CAS 把对象的 Mark Word 改回原来的拷贝（无锁状态的信息），如果成功，说明没其他线程竞争；如果失败，说明自旋的线程已经来抢了，这时候要膨胀为 “重量级锁”。
    为什么不用 Monitor？
    因为 “自旋” 是用户态操作（线程自己在循环检查，不用跟操作系统内核打交道），而 Monitor 的阻塞是内核态操作（需要操作系统介入，把线程挂起）。短期自旋的开销（比如循环 10 次）比内核态切换小得多。但如果竞争激烈，自旋会空耗 CPU（比如 100 个线程都在自旋问 “用完了吗”），反而效率低 —— 这时候就需要升级到重量级锁。
            4. 重量级锁：抢的人太多，必须排队（终于用到 Monitor 了）
    场景：大量线程激烈竞争（比如 100 个线程同时抢一个锁），轻量级锁的自旋已经扛不住了（空耗 CPU 太严重）。核心逻辑：用 Monitor 来管理线程排队和阻塞 —— 就像超市人太多，自助结账撑不住了，开人工柜台，大家排一队，一个一个来，虽然慢但不会乱。
    详细过程：
    升级为重量级锁时：对象的 Mark Word 会改成 “指向 Monitor 对象的指针”（锁标志位改为 10）。从此，线程抢锁不再用 CAS 自旋，而是通过 Monitor 来管理。
    线程抢锁：
    线程想进入同步块，会去尝试获取 Monitor 的 “Owner”（拥有者）身份。
    成功：成为 Owner，进入同步块；
    失败：进入 Monitor 的 EntryList 排队，线程状态变为 “Blocked”（阻塞），不再消耗 CPU。
    线程释放锁：
    线程执行完同步块，会释放 Monitor 的 Owner 身份，然后唤醒 EntryList 里的一个线程来竞争。
    如果线程调用 wait ()：
    会释放 Owner 身份，进入 Monitor 的 WaitSet 等待，直到被 notify () 唤醒，再回到 EntryList 排队。
    为什么这时候必须用 Monitor？
    因为竞争太激烈时，自旋已经毫无意义（100 个线程自旋就是 100 个核心空转），必须让没抢到锁的线程 “休息”（阻塞），这时候只能依赖操作系统的内核态机制（Monitor 本质是对操作系统 “互斥量” 的封装）。虽然内核态切换（用户态→内核态）开销大，但总比 100 个线程空耗 CPU 强。
    总结：锁升级的完整流程（从无到有，从轻到重）
    无锁：对象刚创建，没人用同步块，Mark Word 存哈希码等信息。
    偏向锁：只有一个线程用，Mark Word 贴线程 ID，省掉加锁解锁开销。
    轻量级锁：少量竞争，用 CAS 自旋抢锁，避免内核态阻塞。
    重量级锁：竞争激烈，用 Monitor 管理排队阻塞，牺牲速度换稳定。
    核心设计思想：根据竞争程度 “按需分配” 开销—— 能省则省（偏向锁），省不了就高效处理（轻量级锁），实在不行就按规矩来（重量级锁）。这也是 JVM 对 synchronized 进行优化的核心逻辑。


    */

//    这里讨论的 Mark Word，正是 synchronized(obj) { ... } 中 obj 这个对象的对象头里的 Mark Word。






























}
