package com.zhh.handsome.Demo2;

public class Monitor3 {



   /* 要彻底理解偏向锁、轻量级锁、重量级锁，需从「底层设计逻辑」「加解锁流程」「适用场景」三个维度拆解，结合 “对象头 Mark Word 的变化” 和 “JVM 锁升级机制” 逐一分析：
    一、偏向锁：单线程的 “专属标签”（性能最优）
            1. 核心设计逻辑
    目的：消除无竞争场景下的同步开销。假设前提：锁几乎总是由同一个线程多次获取（比如单线程程序，或某个对象长期被一个线程独占）。核心动作：在对象头的Mark Word中 “刻下线程 ID”，后续该线程无需任何同步操作即可直接进入同步块。
            2. 底层数据结构（Mark Word 变化）
    锁状态	Mark Word（32 位示例）	锁标志位
    无锁	哈希码 + 分代年龄 + 无锁标志	01
    偏向锁	线程 ID + Epoch + 分代年龄 + 偏向标志	01（偏向模式）
            3. 加解锁流程
    加锁：线程首次进入synchronized(obj)时，JVM 检查obj的Mark Word：
    若为无锁状态：用CAS 原子操作将Mark Word改为「当前线程 ID + 偏向标志」（类似 “刻名字”）。
    若已偏向其他线程：触发偏向锁撤销（升级为轻量级锁或重量级锁）。
    解锁：偏向锁不需要显式解锁！因为 JVM 假设 “只有当前线程用”，所以退出同步块时，Mark Word仍保留线程 ID（下次自己进同步块时直接放行）。
            4. 关键优化：批量重偏向与批量撤销
    批量重偏向：若一个类的20 个对象都经历了 “偏向锁→轻量级锁” 的升级（即 “名字被擦掉”），JVM 会触发批量重偏向—— 后续新创建的该类对象，会自动偏向于当前线程，减少重复撤销的开销。
    批量撤销：若一个类的偏向锁频繁被撤销（比如 “刻名字反而更麻烦”），JVM 会批量撤销该类所有对象的偏向锁，并标记该类为 “不可偏向”，后续直接用轻量级锁 / 重量级锁。
            5. 适用场景与性能
    最佳场景：单线程或极低竞争场景（如局部变量、缓存对象）。
    性能：几乎无开销（加锁时一次 CAS，解锁时无操作）。
    缺点：多线程竞争时，“撤销偏向锁” 的操作会带来额外开销（需恢复Mark Word为无锁状态）。
    二、轻量级锁：低竞争的 “自旋试探”（平衡性能与互斥）
            1. 核心设计逻辑
    目的：减少少量线程竞争时的阻塞开销（避免直接升级为重量级锁）。假设前提：锁偶尔被多个线程竞争，但竞争时间很短（比如两个线程交替访问同一对象）。核心动作：用CAS 自旋代替 “线程阻塞”，让线程在 “用户态” 忙等（而非内核态阻塞）。
            2. 底层数据结构（Mark Word 变化）
    锁状态	Mark Word（32 位示例）	锁标志位
    无锁	哈希码 + 分代年龄 + 无锁标志	01
    轻量级锁	指向线程栈中 Lock Record 的指针 + 轻量级锁标志	00
            3. 加解锁流程
    加锁：线程进入synchronized(obj)时，JVM 在线程栈帧中创建一个「锁记录（Lock Record）」，存obj的Mark Word拷贝，然后用CAS尝试将obj的Mark Word改为「指向 Lock Record 的指针」：
    CAS 成功：抢到锁，进入同步块。
    CAS 失败：说明有其他线程竞争，触发自旋（循环几次重新 CAS）；若自旋多次失败，升级为重量级锁。
    解锁：用CAS将obj的Mark Word恢复为 “无锁状态的拷贝”：
    若成功：无竞争，锁回到无锁状态。
    若失败：说明自旋的线程已来抢锁，触发锁膨胀（升级为重量级锁）。
            4. 自旋的 “取舍”
    优点：自旋是用户态操作（无需操作系统内核介入），比 “线程阻塞” 的开销小（内核态切换需约 1000 个 CPU 周期）。
    缺点：自旋会空耗 CPU（比如 10 个线程自旋，相当于 10 个核心空转）。因此，JVM 会限制自旋次数（默认 10 次左右），超过则升级为重量级锁。
            5. 适用场景与性能
    最佳场景：低竞争、同步块执行时间短的场景（如简单的计数器递增）。
    性能：加解锁需 1-2 次 CAS，自旋失败则开销陡增（需升级为重量级锁）。
    缺点：高竞争时自旋无意义，反而浪费 CPU。
    三、重量级锁：高竞争的 “排队闸门”（安全优先）
            1. 核心设计逻辑
    目的：保证高竞争场景下的线程安全（即使牺牲性能）。假设前提：锁被大量线程频繁竞争（比如 100 个线程同时抢一个锁）。核心动作：依赖操作系统的互斥量（Mutex），让未抢到锁的线程 “阻塞休眠”，避免 CPU 空耗。
            2. 底层数据结构（Mark Word 变化）
    锁状态	Mark Word（32 位示例）	锁标志位
    无锁	哈希码 + 分代年龄 + 无锁标志	01
    重量级锁	指向 Monitor 对象的指针 + 重量级锁标志	10
            3. 加解锁流程（结合 Monitor 机制）
    Monitor是操作系统级的 “锁管理器”，内部有三个核心队列：
    Owner：持有锁的线程（正在执行同步块）。
    EntryList：未抢到锁，正在排队的线程（状态为Blocked）。
    WaitSet：调用wait()后，暂时释放锁等待通知的线程（状态为Waiting）。
    加锁：线程进入synchronized(obj)时，JVM 将obj的Mark Word改为「指向 Monitor 的指针」，然后尝试获取 Monitor 的Owner身份：
    成功：成为 Owner，执行同步块。
    失败：进入 EntryList 排队，线程阻塞（由操作系统挂起）。
    解锁：线程执行完同步块后，释放 Monitor 的Owner身份，并唤醒 EntryList 中的一个线程（由操作系统调度）。若线程调用wait()，则会释放 Owner 身份，进入 WaitSet，直到被notify()唤醒后回到 EntryList。
            4. 性能开销的根源
    重量级锁的开销来自两次内核态切换：
    线程阻塞时：从用户态→内核态（操作系统将线程标记为Blocked，并调度其他线程）。
    线程唤醒时：从内核态→用户态（操作系统将线程标记为Runnable，重新参与调度）。
            5. 适用场景与性能
    最佳场景：高竞争、同步块执行时间长的场景（如热点数据更新、分布式事务）。
    性能：加解锁涉及内核态切换，开销极大（比轻量级锁慢 100 倍以上）。
    优点：严格保证线程安全，避免 CPU 空耗（阻塞线程不占用 CPU）。
    四、锁升级流程：JVM 的 “按需分配” 策略
    JVM 会根据竞争激烈程度，自动将锁从 “无锁” 逐步升级为 “偏向锁→轻量级锁→重量级锁”：
    无锁：对象刚创建，未被任何线程锁定（Mark Word存哈希码等信息）。
    偏向锁：单线程首次访问（Mark Word存线程 ID，几乎无开销）。
    轻量级锁：出现少量竞争（用 CAS 自旋，用户态操作）。
    重量级锁：竞争激烈（用 Monitor 阻塞，内核态操作）。
    五、性能对比与调优建议
    锁类型	加锁开销	解锁开销	适用场景	JVM 参数调优
    偏向锁	一次 CAS	无操作	单线程 / 极低竞争	-XX:-UseBiasedLocking（关闭偏向锁）
    轻量级锁	1-2 次 CAS	1-2 次 CAS	低竞争 / 短同步块	-XX:PreBlockSpin=10（调整自旋次数）
    重量级锁	内核态切换	内核态切换	高竞争 / 长同步块	避免高竞争设计（如分段锁、无锁结构）
    总结：锁的本质是 “性能与安全的平衡”
    偏向锁：单线程下 “零开销”，用信任换性能。
    轻量级锁：低竞争下 “自旋试探”，用 CPU 空耗换内核态切换。
    重量级锁：高竞争下 “排队阻塞”，用性能换安全。*/


}
/*要理解轻量级锁中 “指向 Lock Record 的指针”，需从 Lock Record 的本质、指针的存储形式 和 它在锁机制中的作用 三个维度拆解：
一、Lock Record：线程栈里的 “锁记录”
Lock Record 是 JVM 在线程栈帧中为轻量级锁专门分配的临时数据结构，包含两部分信息：
Displaced Mark Word：锁对象当前 Mark Word 的拷贝（“Displaced” 意为 “被替换的”，因为加锁后锁对象的 Mark Word 会被修改）。
指向锁对象的引用：记录当前 Lock Record 对应的是哪个锁对象（如 synchronized(obj) 中的 obj）。
二、“指向 Lock Record 的指针”：线程栈的内存地址
这个指针本质是 线程栈中 Lock Record 的内存地址，长度由 JVM 位数决定：
        32 位 JVM：指针占 4 字节（32 位），直接存储 Lock Record 的起始地址。
        64 位 JVM：默认指针占 8 字节（64 位），但开启 +UseCompressedOops（指针压缩）后，占 4 字节（通过偏移量间接表示地址）。
三、指针的核心作用：“标记锁的持有者”
轻量级锁的加锁过程，本质是用 CAS 把锁对象的 Mark Word 改成 “指向当前线程 Lock Record 的指针”，以此标记 “当前线程持有该锁”。具体流程如下：
加锁时：
线程在自己的栈帧中创建 Lock Record，保存锁对象的 Mark Word 拷贝（Displaced Mark Word）。
用 CAS 原子操作尝试将锁对象的 Mark Word 替换为 “指向当前 Lock Record 的指针”（同时将锁标志位改为 00，表示轻量级锁）。
如果 CAS 成功：当前线程抢到锁，进入同步块；
如果 CAS 失败：说明有其他线程竞争，当前线程开始自旋（循环几次后重试 CAS），若自旋失败则升级为重量级锁。
解锁时：
用 CAS 将锁对象的 Mark Word 恢复为 “Displaced Mark Word”（即加锁前的无锁状态）。
如果 CAS 成功：无竞争，锁回到无锁状态；
如果 CAS 失败：说明自旋的线程已修改过 Mark Word，触发锁膨胀（升级为重量级锁）。
四、指针的 “可见性”：为什么其他线程能看到？
锁对象的 Mark Word 存储在堆内存中（所有线程共享堆），而 Lock Record 存储在线程栈内存中（线程私有）。当线程 A 用 CAS 把锁对象的 Mark Word 改成 “指向自己 Lock Record 的指针” 后，线程 B 来抢锁时，会读取锁对象的 Mark Word—— 发现指针指向线程 A 的栈帧，就知道 “锁被 A 占用了”，从而触发自旋或阻塞。
五、和重量级锁的区别：指针指向哪里？
轻量级锁：Mark Word 存的是线程栈中 Lock Record 的指针（用户态操作，无需操作系统介入）。
重量级锁：Mark Word 存的是堆中 Monitor 对象的指针（内核态操作，依赖操作系统阻塞线程）。
总结：指针是 “轻量级锁的身份标识”
轻量级锁通过 “在锁对象的 Mark Word 中写入线程栈内 Lock Record 的地址”，实现了无阻塞的锁竞争（用 CAS 自旋代替线程阻塞）。这种设计让低竞争场景下的锁开销极小，但高竞争时仍需升级为重量级锁 —— 这正是 JVM 锁升级机制的精妙之处。*/







