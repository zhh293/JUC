package com.zhh.handsome.Demo2;

public class 轻量级锁的CAS {




    /*要理解轻量级锁中 CAS（Compare And Swap，比较并交换）的成功与失败过程，我们可以从轻量级锁的设计目的和核心操作对象（Mark Word） 入手，用 “生活场景类比 + 技术步骤拆解” 的方式来说明。
    先明确两个核心前提
    轻量级锁的适用场景：它是 Java 中synchronized的一种优化，适合线程交替执行同步块的场景（几乎无竞争），避免重量级锁的性能开销（如内核态切换）。
    Mark Word 的作用：每个 Java 对象头中都有一块叫 “Mark Word” 的内存区域，用来存储对象的锁状态、哈希码、分代年龄等信息。轻量级锁的所有操作，本质都是对这个 “Mark Word” 的修改。
    无锁状态下，Mark Word 的结构大致是：[哈希码][分代年龄][01]（最后两位 “01” 是锁标志位，代表无锁）。
    场景铺垫：线程进入同步块时的操作
    当线程要进入synchronized同步块时，轻量级锁的获取过程会先做两件事：
    线程在自己的栈帧中创建一个锁记录（Lock Record） 空间，用于存储 “当前对象 Mark Word 的副本”（这个副本叫 Displaced Mark Word）。
    尝试用CAS 操作把对象的 Mark Word 改成 “指向自己锁记录的指针”（同时锁标志位改为 “00”，代表轻量级锁）。
    一、CAS 成功的过程（无竞争场景）
    类比场景：你想进一个房间（同步块），房间门口有个牌子（Mark Word）写着 “无人占用”。你把牌子翻成 “由我占用”，然后进入房间。
    技术步骤：
    //如果发现是无人占用，那么准备下一步的CAS更新Mark Word，如果发现已经被人使用了，那么就升级为重量级锁
    线程 A 复制对象的 Mark Word 到自己的锁记录（得到 Displaced Mark Word）。
    线程 A 执行 CAS：比较对象当前的 Mark Word 是否和 “无锁状态的 Mark Word” 一致（即是否还是原来的哈希码 + 01 标志）。
    如果一致：CAS 成功，将对象的 Mark Word 更新为 “指向线程 A 锁记录的指针 + 00 标志”（表示对象被线程 A 轻量级锁定）。
    线程 A 顺利进入同步块执行代码。
    关键：此时对象的 Mark Word 已经不再是原始的哈希码，而是指向线程 A 锁记录的指针，其他线程看到这个标志，就知道对象被占用了。
    二、CAS 失败的过程（两种情况）
    CAS 失败的核心原因：线程执行 CAS 时，发现对象当前的 Mark Word 和 “预期的无锁状态 Mark Word” 不一致了。具体分两种情况：
    情况 1：其他线程已经持有轻量级锁（有竞争）
    类比场景：你想进房间，发现牌子已经被别人（线程 B）改成 “由 B 占用”，你没法直接进，只能升级为 “排队等待”。
    技术步骤：
    线程 A 复制对象 Mark Word 到自己的锁记录。
    线程 A 执行 CAS 时，发现对象的 Mark Word 已经变成 “指向线程 B 锁记录的指针 + 00 标志”（说明线程 B 已经持有轻量级锁）。
    CAS 失败，此时轻量级锁无法满足需求，会膨胀为重量级锁：
    线程 A 将对象的 Mark Word 修改为 “指向重量级锁（互斥量）的指针 + 10 标志”（表示对象进入重量级锁状态）。
    线程 A 自己进入阻塞状态，等待重量级锁的唤醒（像排队一样，由操作系统调度）。
    原来持有轻量级锁的线程 B，在释放锁时会发现锁已经膨胀，会去唤醒阻塞队列中的线程。
    情况 2：当前线程重入同步块（无竞争，自己再次进入）
    类比场景：你已经在房间里了，又想进房间里的一个小隔间（重入同步块），不需要重新翻牌子，直接登记一下即可。
    技术步骤：
    线程 A 已经持有轻量级锁（对象 Mark Word 指向 A 的锁记录）。
    线程 A 再次进入同步块（重入），会再创建一个新的锁记录。
    代码逻辑应该是先比较判断mark word是指向自己线程的指针+00标志，如果是，则说明当前线程是重入的，不需要再执行CAS。
    这个新锁记录的 “Displaced Mark Word” 设为null（因为不需要复制原始 Mark Word 了）。
    线程 A 直接进入同步块，无需再次执行 CAS（避免重复竞争）。
    关键：轻量级锁通过 “锁记录的数量” 记录重入次数，释放时也会按次数依次销毁锁记录。
    最后：轻量级锁的释放过程（与 CAS 对应）
    当线程退出同步块时，会尝试用 CAS 把锁记录中的 “Displaced Mark Word”（原始的无锁状态 Mark Word）恢复到对象的 Mark Word 中：
    如果 CAS 成功：说明释放期间没有其他线程竞争，对象回到无锁状态。
    如果 CAS 失败：说明锁已经膨胀为重量级锁，此时需要释放重量级锁，并唤醒阻塞的线程。
    总结
    CAS 成功：无竞争，当前线程顺利拿到轻量级锁，对象 Mark Word 指向线程的锁记录。
    CAS 失败：
    若其他线程持有锁：轻量级锁膨胀为重量级锁，当前线程阻塞。
    若当前线程重入：直接创建新锁记录，无需竞争。
    轻量级锁的 CAS 操作本质是 “用自旋（无阻塞）的方式尝试获取锁”，只有在真正有竞争时才会升级为重量级锁，平衡了性能和正确性。*/

















/*
    那如果这个线程复制lock record的时候，对象里面的mark word已经被修改过了，已经是指向其他线程的指针了，那这时这个线程会继续复制还是直接宣布CAS失败
    当线程复制锁记录（Lock Record）时，如果对象的 Mark Word 已经被修改（比如指向其他线程的锁记录），线程会先完成复制操作，但随后的 CAS 操作会直接失败，进而触发锁膨胀流程。
    具体过程拆解：
    我们用 “线程 A 尝试获取锁，而对象的 Mark Word 已被线程 B 修改” 为例说明：
    线程 A 复制 Mark Word 到锁记录线程 A 进入同步块时，会先在自己的栈帧中创建锁记录，然后将对象当前的 Mark Word（此时已被线程 B 修改为 “指向 B 的锁记录的指针 + 00 标志”）复制到自己的锁记录中（作为 Displaced Mark Word）。这里的 “复制” 是被动读取当前状态，不管 Mark Word 是什么值（无锁、指向其他线程、重量级锁等），都会如实复制。
    线程 A 执行 CAS 操作，发现失败接下来，线程 A 会执行 CAS 操作，核心逻辑是：“比较对象当前的 Mark Word 是否等于我复制到锁记录里的 Displaced Mark Word？如果是，就把对象的 Mark Word 改成指向我自己锁记录的指针”。
    但此时：
    线程 A 锁记录中的 Displaced Mark Word 是 “指向 B 的锁记录的指针”（复制时的状态）。
    对象当前的 Mark Word 仍然是 “指向 B 的锁记录的指针”（因为线程 B 还没释放锁）。
    从表面看，两者相等，CAS 似乎会成功？但这显然违反锁的排他性（不能同时让两个线程持有锁）。
    这里的关键是：轻量级锁的 CAS 隐含了 “对象必须处于可竞争状态” 的前提—— 即只有当对象处于 “无锁状态”（Mark Word 最后两位为 01）时，CAS 的替换才被允许。当 Mark Word 已经是 “指向其他线程锁记录”（标志位 00）时，即使 CAS 的 “比较” 步骤相等，JVM 也会判定为 “存在竞争”，导致 CAS 逻辑上失败。
    CAS 失败后：锁膨胀线程 A 发现 CAS 失败（本质是检测到对象已被其他线程锁定），会触发轻量级锁的 “膨胀” 机制：
    将对象的 Mark Word 修改为 “指向重量级锁（互斥量）的指针 + 10 标志”，彻底转为重量级锁。
    线程 A 自身进入阻塞状态，加入重量级锁的等待队列，由操作系统负责后续调度。
    线程 B 释放锁时，会发现锁已膨胀，进而唤醒阻塞队列中的线程（如线程 A）。
    一句话总结：
    线程会先复制当前的 Mark Word（哪怕已被修改），但 CAS 操作会因为检测到 “对象已被其他线程锁定” 而失败，最终导致锁膨胀为重量级锁，当前线程进入阻塞等待。*/

















   /* 可重入锁在 CAS 操作时之所以能 “成功”，核心原因是：重入场景中，线程再次获取锁时并不会真正执行 “竞争式的 CAS”，而是通过 “识别自身持有状态” 直接放行，本质上避免了 CAS 失败的可能。
    具体过程：用 “第一次获取” 和 “重入获取” 对比说明
    我们以同一个线程（线程 A）两次进入同一个synchronized同步块为例：
            1. 第一次获取锁：执行 CAS 并成功
    线程 A 创建第一个锁记录（Lock Record 1），复制对象的无锁状态 Mark Word（含哈希码、01 标志位）到 Lock Record 1 的 Displaced Mark Word 中。
    执行 CAS：尝试将对象的 Mark Word 改为 “指向 Lock Record 1 的指针 + 00 标志位（轻量级锁）”。
    此时无竞争，CAS 成功，对象 Mark Word 被更新，线程 A 持有轻量级锁。
            2. 重入获取锁：不执行竞争式 CAS，直接成功
    当线程 A 再次进入同一个同步块（重入）时，流程完全不同：
    线程 A 会创建第二个锁记录（Lock Record 2），但不会复制对象当前的 Mark Word，而是将 Lock Record 2 的 Displaced Mark Word 设为null（特殊标记）。
    然后，线程 A 会检查对象当前的 Mark Word：发现它指向的是自己线程栈中的 Lock Record 1（即 “当前线程已经持有该锁”）。
    关键：此时 JVM 会直接判定 “重入成功”，无需执行 CAS 操作（因为不需要和任何人竞争，锁已经属于自己）。线程 A 直接进入同步块，同时通过 “新增锁记录” 的方式记录重入次数。
    为什么重入时不需要 CAS？
    CAS 的核心作用是 “解决多线程竞争”，而重入是同一个线程内部的操作，不存在 “其他线程修改 Mark Word” 的风险。此时：
    对象的 Mark Word 始终指向当前线程的锁记录（不会被其他线程修改）。
    线程只需通过 “检查 Mark Word 是否指向自己的锁记录”，就能确认 “自己已经持有锁”，无需再用 CAS 去 “争夺”。
    重入时的 “CAS 成功” 本质
    严格来说，重入时并没有执行 “竞争式的 CAS”（即不会尝试修改 Mark Word），但从 “获取锁成功” 的结果来看，相当于 CAS “逻辑成功”。这是因为：
    重入不涉及锁的 “所有权变更”，只是增加持有计数。
    JVM 通过 “锁记录的数量” 跟踪重入次数（有多少个null 的 Displaced Mark Word 锁记录，就代表重入了多少次）。
    总结
    可重入锁的 CAS “成功”，本质是重入场景中跳过了真正的竞争式 CAS。因为线程已经持有锁，只需通过 “识别自身锁记录” 直接放行，无需和其他线程（或自己）竞争，自然不会出现 CAS 失败的情况。这既保证了重入性，又避免了不必要的性能开销。*/






//    与轻量级锁 / 重量级锁不同，持有偏向锁的线程在退出同步块时，不会主动修改 Mark Word（不会清除线程 ID，也不会改回无锁状态）。













   /* 轻量级锁的膨胀（Inflation）是 Java 虚拟机（以 HotSpot 为例）在检测到锁竞争无法通过轻量级机制解决时，将轻量级锁升级为重量级锁的过程。这一机制的核心是：当多个线程竞争同一把轻量级锁时，放弃基于 CAS 的自旋尝试，转而使用操作系统级别的互斥量（重量级锁）来管理线程的阻塞与唤醒，避免无意义的 CPU 空转。
    轻量级锁膨胀的完整流程（基于 HotSpot 实现）
    前提：轻量级锁的正常持有状态
    在理解膨胀前，先明确轻量级锁的 “正常状态”：
    线程 A 进入同步块时，通过 CAS 将对象的Mark Word修改为 “轻量级锁标志（lock=00）+ 指向线程 A 栈帧中 Lock Record 的指针”；
    线程 A 的 Lock Record 中，Displaced Mark Word保存着对象原始的无锁状态 Mark Word（供释放锁时恢复）；
    此时对象处于 “轻量级锁定” 状态，线程 A 持有该锁。
    步骤 1：竞争发生（触发膨胀的条件）
    当线程 B 尝试进入同一同步块时，会执行轻量级锁的获取流程，却发现锁已被线程 A 持有，具体表现为：
    线程 B 读取对象 Mark Word，发现其状态为 “轻量级锁（lock=00）”，且指针指向线程 A 的 Lock Record（非空）；
    线程 B 在自己的栈帧中创建 Lock Record，并将当前 Mark Word（即指向 A 的 Lock Record 的指针）复制到自己的Displaced Mark Word中；
    线程 B 尝试执行 CAS（将对象 Mark Word 改为指向自己的 Lock Record），但此时检测到 “锁已被其他线程持有”（Mark Word 的lock=00且指向其他线程），轻量级锁的 CAS 机制无法处理这种竞争，触发膨胀流程。



    步骤 2：创建重量级锁的核心结构（ObjectMonitor）
    膨胀的第一步是为同步对象分配一个ObjectMonitor（重量级锁的核心数据结构），它是实现线程阻塞 / 唤醒的关键，包含以下核心字段：
    _owner：指向当前持有锁的线程（初始为null）；
    _EntryList：等待获取锁的线程队列（阻塞状态）；
    _WaitSet：调用wait()后进入等待状态的线程队列；
    _recursions：重入次数（支持锁重入）；
    _cxq：竞争队列（双向链表，临时存放竞争线程）。


    步骤 3：更新对象头为重量级锁状态
    线程 B（竞争线程）会执行以下操作，将对象从 “轻量级锁” 转为 “重量级锁”：
    通过 CAS 将对象的Mark Word从 “轻量级锁标志（lock=00）+ 指向 A 的 Lock Record 的指针” 修改为 “重量级锁标志（lock=10）+ 指向新创建的 ObjectMonitor 的指针”；
    若 CAS 成功，对象正式进入 “重量级锁定” 状态；
    若 CAS 失败（可能有其他线程同时尝试膨胀），则通过自旋重试，确保最终只有一个线程完成膨胀。
    步骤 4：关联原持有线程与 ObjectMonitor
    膨胀后，需要将原持有轻量级锁的线程 A 与 ObjectMonitor 关联，确保线程 A 仍能正常释放锁：
    线程 B（或完成膨胀的线程）会遍历线程 A 的栈帧，找到其持有的 Lock Record（通过对象 Mark Word 中原先的指针）；
    将线程 A 的 Lock Record 中的Displaced Mark Word（即对象原始的无锁 Mark Word）保存到 ObjectMonitor 的_header字段中（作为后续释放锁时的恢复依据）；
    将 ObjectMonitor 的_owner字段设置为线程 A，标记线程 A 为重量级锁的当前持有者；
    线程 A 的 Lock Record 中会记录 “当前锁已膨胀”（通过特殊标志），使其后续释放锁时能识别重量级锁状态。
    步骤 5：竞争线程进入阻塞队列
    线程 B 完成膨胀后，自身无法获取锁，会进入阻塞状态：
    线程 B 将自己封装为ObjectWaiter节点，加入 ObjectMonitor 的_EntryList（或_cxq）队列；
    调用操作系统的阻塞原语（如park()），将自己从 “运行状态” 转为 “阻塞状态”，释放 CPU 资源；
    此时线程 B 的状态由 JVM 管理，等待被唤醒。
    步骤 6：原持有线程释放锁与唤醒竞争线程
    当线程 A 执行完同步块，释放锁时，会发现锁已膨胀为重量级锁，执行以下操作：
    线程 A 检查自己的 Lock Record，发现 “锁已膨胀” 标志，转而操作 ObjectMonitor；
    检查 ObjectMonitor 的_recursions（重入次数），若大于 0 则递减（支持重入），直至为 0 时准备释放；
    释放时，将 ObjectMonitor 的_owner设为null，并从_EntryList（或_cxq）中唤醒一个等待线程（如线程 B）；
    被唤醒的线程 B 会重新尝试获取重量级锁（通过 CAS 将_owner设为自己），成功则进入同步块，失败则继续阻塞。
    总结：轻量级锁膨胀的核心目的
    轻量级锁依赖 CAS 操作，适合 “无竞争” 或 “短时间竞争” 场景，但当竞争持续存在时：
    自旋 CAS 会浪费 CPU 资源（线程空转）；
    多线程竞争会导致 CAS 频繁失败，效率低下。
    而膨胀为重量级锁后，通过操作系统的互斥量机制，让竞争线程进入阻塞状态（不占用 CPU），虽然阻塞 / 唤醒有额外开销，但适合 “长时间竞争” 场景，避免了无意义的 CPU 消耗。*/














}
