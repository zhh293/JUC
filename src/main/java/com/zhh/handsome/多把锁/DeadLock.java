package com.zhh.handsome.多把锁;

public class DeadLock {
   /* 死锁是多线程并发中一种典型的 “卡死” 问题，简单说就是：多个线程互相抱着对方需要的资源，谁都不肯放手，导致所有线程都永远停在等待状态。
    用生活场景理解死锁：
    想象两个小朋友玩积木：
    小明手里拿着红色积木，同时想要小刚手里的蓝色积木；
    小刚手里拿着蓝色积木，同时想要小明手里的红色积木；
    两人都不肯先放下自己手里的积木，又都等着对方给，结果就一直僵持着 —— 这就是 “死锁”。
    对应到线程中：
    线程要操作共享资源时，需要先获取资源对应的锁。如果：
    线程 A 持有锁 1，同时等待获取线程 B 持有的锁 2；
    线程 B 持有锁 2，同时等待获取线程 A 持有的锁 1；
    此时两个线程会永远等待对方释放锁，谁都无法继续执行，就形成了死锁。
    用代码演示死锁（Java）：
    我们修改之前的银行转账代码，故意去掉 “按顺序获取锁” 的逻辑，就能模拟死锁：
    Java死锁演示示例
            V1
    创建时间：14:52
    为什么会产生死锁？
    上面的代码大概率会卡死，因为：
    线程 1 先锁了 A，准备锁 B；
    线程 2 先锁了 B，准备锁 A；
    两者互相等待对方释放锁，永远僵持。
    死锁产生的 4 个必要条件（缺一不可）：
    互斥条件：资源（锁）只能被一个线程持有（比如一把锁不能同时给两个线程）；
    持有并等待：线程持有一个资源，同时等待另一个资源；
    不可剥夺：资源（锁）不能被强行夺走，只能由持有方主动释放；
    循环等待：多个线程形成 “你等我，我等他，他等你” 的循环链。
    如何避免死锁？
    只要打破 4 个条件中的任何一个即可，最常用的是打破 “循环等待”：
    按固定顺序获取锁：比如规定 “永远先锁 ID 小的账户，再锁 ID 大的账户”（之前多锁银行的正确写法）。
    这样线程 1 和线程 2 都会先尝试锁 ID 小的账户，就不会形成循环等待。
    其他方法：
    限时等待：用tryLock(timeout)，超时后放弃获取锁并释放已持有的锁；
    一次性获取所有资源：先检查需要的所有锁，能同时获取才操作，否则都不获取。
    总结：死锁是多锁场景下的 “隐形陷阱”，核心是 “循环等待资源”。通过合理规划锁的获取顺序，能有效避免这种问题。*/
}
