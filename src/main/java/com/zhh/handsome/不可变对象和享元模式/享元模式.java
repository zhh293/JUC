// // 一、先看生活例子：什么是 “享元”？
// // “享元” 的核心是「共享 + 复用」—— 对于大量相同 / 相似的对象，只创建一个 “模板” 对象，然后复用它，避免重复创建导致的内存浪费。
// // 举 3 个最直观的生活场景：
// // 共享单车：城市里不需要给每个人配一辆专属单车（重复创建对象），而是投放一批共享单车（享元对象），大家按需使用（复用），用完后放回原地供其他人继续用；
// // 文字编辑器：你在 Word 里输入 100 个 “a”，编辑器不会创建 100 个独立的 “a” 对象（每个都存储字体、大小、颜色），而是只创建 1 个 “a” 的 “模板”（存储共享属性），然后给每个 “a” 分配不同的「位置坐标」（差异化属性），复用同一个模板渲染；
// // 打印机耗材：公司有 10 台打印机，不需要给每台配一套独立的 “打印驱动程序”（相同对象），而是让所有打印机共享同一个驱动程序（享元对象），只传入不同的打印参数（文件内容、份数）。
// // 简单说：享元模式 = 共享的 “模板” + 外部传入的 “差异化参数”，本质是 “以空间换时间”（减少对象创建，节省内存）。


// 二、核心定义：享元模式到底是什么？
// 官方定义：一种结构型设计模式，通过复用大量相同 / 相似的对象，减少对象创建的数量，从而降低内存占用和系统开销。
// 核心拆解：
// 享元（Flyweight）：可被复用的 “共享对象”（比如共享单车、文字编辑器的 “a” 模板）；
// 内部状态（Intrinsic State）：享元对象的「固定属性」（比如 “a” 的字体、大小、颜色，共享单车的品牌、型号），是共享的、不可变的（所以享元对象通常是「不可变对象」，呼应上一篇！）；
// 外部状态（Extrinsic State）：享元对象的「可变属性」（比如 “a” 的位置坐标，共享单车的使用人、当前位置），是随场景变化的，需要从外部传入，不存储在享元对象中；
// 享元工厂（Flyweight Factory）：负责创建和管理享元对象的 “仓库”—— 当需要一个享元时，先查仓库，有就直接返回，没有再创建并加入仓库（缓存逻辑）。
// 三、为什么需要享元模式？（核心价值）
// 解决「大量相同 / 相似对象导致的内存溢出」问题，主要有 3 个优势：
// 减少内存占用：重复对象只创建一次，比如 1000 个 “a” 只占 1 个对象的内存，而不是 1000 个；
// 提高系统性能：减少对象创建和销毁的次数，降低 GC（垃圾回收）压力；
// 统一管理共享对象：通过享元工厂集中管理，便于维护（比如修改所有 “a” 的字体，只需改一个模板）。




// 如果文字编辑器对每个字符都创建独立对象：
// java
// 运行
// // 无享元模式：每个字符都是独立对象，存储所有属性
// class Char {
//     private char value; // 字符值（如'a'）
//     private String font; // 字体
//     private int size; // 大小
//     private int x; // 位置x
//     private int y; // 位置y

//     // 构造方法、getter/setter...
// }

// // 输入1000个'a'，创建1000个Char对象，每个都存储font、size（重复数据）
// List<Char> chars = new ArrayList<>();
// for (int i = 0; i < 1000; i++) {
//     chars.add(new Char('a', "微软雅黑", 12, i*10, 20));
// }
// 问题：1000 个对象的font和size完全相同，却重复存储 1000 次，严重浪费内存！


// 四、享元模式的设计原理（4 个核心角色）
// 享元模式的结构很清晰，包含 4 个关键角色，用 “文字编辑器” 场景对应：
// 角色	作用	文字编辑器案例
// 抽象享元（Flyweight）	定义享元对象的接口，声明操作（传入外部状态）	CharFlyweight 接口，定义render(x,y)方法
// 具体享元（Concrete Flyweight）	实现抽象享元，存储「内部状态」（不可变）	ConcreteChar 类，存储value（字符）、font（字体）、size（大小）
// 享元工厂（Flyweight Factory）	缓存享元对象，负责创建 / 复用	CharFactory 类，用 Map 缓存ConcreteChar，key 是 “字符 - 字体 - 大小”
// 客户端（Client）	提供「外部状态」，调用享元对象的操作	编辑器本身，传入每个字符的x,y坐标，调用render(






// 五、实战：用享元模式实现文字编辑器
// 我们用代码还原 “文字编辑器渲染字符” 的场景，严格遵循上面的 4 个角色：
// 步骤 1：定义抽象享元（接口）
// 声明享元对象的核心操作，传入外部状态（位置坐标 x,y）：
// java
// 运行
// // 抽象享元：字符享元接口
// public interface CharFlyweight {
//     // 渲染字符（传入外部状态：位置x,y）
//     void render(int x, int y);
// }
// 步骤 2：实现具体享元（存储内部状态）
// 存储不可变的内部状态（字符值、字体、大小），实现渲染逻辑：
// java
// 运行
// // 具体享元：实际的字符对象（不可变）
// public class ConcreteChar implements CharFlyweight {
//     // 内部状态：不可变（final + 无setter）
//     private final char value; // 字符值（如'a'）
//     private final String font; // 字体（如"微软雅黑"）
//     private final int size; // 字号（如12）

//     // 构造方法：初始化内部状态（只能通过构造器赋值，不可修改）
//     public ConcreteChar(char value, String font, int size) {
//         this.value = value;
//         this.font = font;
//         this.size = size;
//     }

//     // 实现渲染方法：结合内部状态和外部状态（x,y）
//     @Override
//     public void render(int x, int y) {
//         System.out.printf("渲染字符：'%c'，字体：%s，大小：%d，位置：(%d,%d)%n",
//                 value, font, size, x, y);
//     }

//     // 重写equals和hashCode：用于享元工厂的缓存key（判断是否为相同享元）
//     @Override
//     public boolean equals(Object o) {
//         if (this == o) return true;
//         if (o == null || getClass() != o.getClass()) return false;
//         ConcreteChar that = (ConcreteChar) o;
//         return value == that.value && size == that.size && font.equals(that.font);
//     }

//     @Override
//     public int hashCode() {
//         return Objects.hash(value, font, size);
//     }
// }
// 步骤 3：实现享元工厂（缓存 + 创建享元）
// 用Map缓存享元对象，确保相同内部状态的对象只创建一次：
// java
// 运行
// // 享元工厂：管理和复用享元对象
// public class CharFactory {
//     // 缓存池：key是"字符-字体-大小"（或直接用ConcreteChar对象作为key，依赖其hashCode/equals）
//     private static final Map<ConcreteChar, CharFlyweight> CACHE = new HashMap<>();

//     // 私有构造器：禁止外部实例化（单例工厂）
//     private CharFactory() {}

//     // 核心方法：获取享元对象（有则复用，无则创建）
//     public static CharFlyweight getChar(char value, String font, int size) {
//         // 1. 构造一个"候选享元"（用于查询缓存）
//         ConcreteChar candidate = new ConcreteChar(value, font, size);
        
//         // 2. 缓存中存在则返回，不存在则创建并加入缓存
//         return CACHE.computeIfAbsent(candidate, k -> new ConcreteChar(value, font, size));
//     }

//     // 可选：查看缓存大小（验证复用效果）
//     public static int getCacheSize() {
//         return CACHE.size();
//     }
// }
// 步骤 4：客户端调用（传入外部状态）
// 模拟文字编辑器输入字符，传入位置坐标（外部状态）：
// java
// 运行
// public class TextEditor {
//     public static void main(String[] args) {
//         // 场景：输入5个字符，其中3个是"a-微软雅黑-12"（相同内部状态），2个是"b-宋体-14"（相同内部状态）
//         CharFlyweight a1 = CharFactory.getChar('a', "微软雅黑", 12);
//         CharFlyweight a2 = CharFactory.getChar('a', "微软雅黑", 12);
//         CharFlyweight a3 = CharFactory.getChar('a', "微软雅黑", 12);
//         CharFlyweight b1 = CharFactory.getChar('b', "宋体", 14);
//         CharFlyweight b2 = CharFactory.getChar('b', "宋体", 14);

//         // 验证：相同内部状态的对象是同一个（复用成功）
//         System.out.println("a1 == a2？" + (a1 == a2)); // true
//         System.out.println("b1 == b2？" + (b1 == b2)); // true
//         System.out.println("缓存大小：" + CharFactory.getCacheSize()); // 2（只创建了2个享元对象）

//         // 渲染字符：传入外部状态（位置坐标）
//         a1.render(10, 20);  // 渲染字符：'a'，字体：微软雅黑，大小：12，位置：(10,20)
//         a2.render(20, 20);  // 渲染字符：'a'，字体：微软雅黑，大小：12，位置：(20,20)
//         a3.render(30, 20);  // 渲染字符：'a'，字体：微软雅黑，大小：12，位置：(30,20)
//         b1.render(10, 40);  // 渲染字符：'b'，字体：宋体，大小：14，位置：(10,40)
//         b2.render(20, 40);  // 渲染字符：'b'，字体：宋体，大小：14，位置：(20,40)
//     }
// }
// 运行结果分析：
// 虽然输入了 5 个字符，但缓存大小只有 2（只创建了 2 个享元对象），实现了复用；
// 相同内部状态的a1/a2/a3是同一个对象，b1/b2是同一个对象；
// 渲染时通过传入不同的x,y（外部状态），实现了差异化展示，而内部状态（字体、大小）共享不变。
// 六、Java 中内置的享元模式应用
// Java 很多核心类都用到了享元模式，本质都是 “复用相同对象，减少内存占用”：
// 1. String 常量池（最典型）
// 内部状态：字符串的字符序列（如 "abc"）；
// 外部状态：无（String 本身是不可变对象，无需外部状态）；
// 享元工厂：JVM 的 String 常量池（String.intern()方法可手动将字符串加入常量池复用）。
// 示例：
// java
// 运行
// String s1 = "abc";
// String s2 = "abc";
// System.out.println(s1 == s2); // true（复用常量池中的同一个对象）
// 2. 包装类缓存池（Integer、Long 等）
// 内部状态：基本类型值（如 123）；
// 外部状态：无；
// 享元工厂：包装类的valueOf()方法（缓存 - 128~127 之间的对象）。
// 示例：
// java
// 运行
// Integer i1 = Integer.valueOf(123);
// Integer i2 = Integer.valueOf(123);
// System.out.println(i1 == i2); // true（复用缓存池中的对象）

// Integer i3 = Integer.valueOf(200);
// Integer i4 = Integer.valueOf(200);
// System.out.println(i3 == i4); // false（超出缓存范围，创建新对象）
// 3. 线程池（ExecutorService）
// 内部状态：线程的核心属性（如优先级、是否守护线程）；
// 外部状态：待执行的任务（Runnable）；
// 享元工厂：线程池（复用核心线程，避免频繁创建销毁线程）。
// 4. 其他
// IntegerCache、LongCache：包装类的缓存实现；
// Character.UnicodeBlock：复用 Unicode 字符块的常量对象；
// 数据库连接池：复用数据库连接（内部状态：连接 URL、用户名、密码；外部状态：SQL 语句、参数）。
// 七、享元模式的适用场景与优缺点
// 适用场景（满足以下条件优先用）
// 系统中存在大量相同 / 相似对象（如文字编辑器的字符、系统中的线程）；
// 对象的内部状态稳定、不可变（便于共享），外部状态可独立于对象（便于传入）；
// 内存资源紧张，需要减少对象创建导致的内存开销；
// 对象创建成本高（如数据库连接、线程），复用能显著提升性能。
// 优点
// 减少对象数量，降低内存占用（核心优势）；
// 减少对象创建和销毁的开销，提高系统响应速度；
// 统一管理共享对象，便于维护和扩展（如修改所有字符的字体，只需改享元对象）。
// 缺点
// 增加系统复杂度：需要拆分 “内部状态” 和 “外部状态”，还要实现享元工厂的缓存逻辑；
// 外部状态需从外部传入，可能增加参数传递的开销；
// 若内部状态设计不当（如包含可变属性），会导致线程安全问题（所以享元对象必须是不可变的！）。
// 八、常见误区澄清
// 「享元模式就是缓存？」错！缓存是享元模式的「实现手段」，但享元模式不止是缓存：享元模式还要求拆分 “内部状态” 和 “外部状态”，而缓存只是单纯的 “存储复用对象”（不一定有状态拆分）。
// 「享元对象可以是可变的？」错！享元对象的内部状态必须是不可变的—— 否则一个客户端修改了内部状态，会影响所有复用该对象的客户端（比如文字编辑器的 “a” 字体被改成黑体，所有 “a” 都会变成黑体，这是 bug）。
// 「所有对象都能复用？」错！只有「内部状态稳定、外部状态可拆分」的对象才能用享元模式。如果对象的所有属性都是可变的（比如用户对象，每个用户的姓名、年龄、地址都不同），无法拆分内部 / 外部状态，就不适合用。
// 「享元工厂必须是单例？」通常是单例（避免多个工厂创建重复享元），但不是强制要求 —— 若系统需要按模块隔离享元，也可以创建多个工厂（比如不同模块的字符缓存池）。
// 九、享元模式与不可变对象的关联（重点回顾）
// 两者是 “相辅相成” 的关系：
// 不可变对象是享元模式的「基础」：享元对象的内部状态必须不可变，才能安全地被多个客户端共享（否则会出现线程安全问题）；
// 享元模式是不可变对象的「应用场景」：不可变对象的状态固定，天生适合被复用，而享元模式就是专门最大化复用这类对象的设计模式。
// 简单说：享元模式 = 不可变对象 + 缓存工厂 + 状态拆分。
// 十、总结
// 享元模式的核心是「共享复用相同 / 相似对象，减少内存开销」，关键是拆分「内部状态（不可变、共享）」和「外部状态（可变、传入）」，通过享元工厂管理缓存。
// 生活类比：共享单车、文字编辑器的字符、打印机驱动；
// 核心角色：抽象享元、具体享元（不可变）、享元工厂（缓存）、客户端（传入外部状态）；
// 典型应用：String 常量池、包装类缓存、线程池；
// 适用场景：大量相同对象、内存紧张、对象创建成本高。