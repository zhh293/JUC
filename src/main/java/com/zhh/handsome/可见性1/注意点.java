package com.zhh.handsome.可见性1;

public class 注意点 {

    /*volatile不能解决指令交错的问题，因为当两个线程分别执行++，--。而这两个指令在底层可能会发生这种情况，当++读取完当前值的时候，cpu执行权被--夺走，他也读取当前值，这样的话即便执行了--，然后值也是立马可见的，但是++之后也不会执行读取操作了，按照之前读取的值进行自增操作，所以无法避免，对吧
    你的理解完全正确！volatile 之所以无法解决 ++ 和 -- 这类操作的指令交错问题，核心原因是：volatile 仅保证可见性和禁止指令重排序，但不保证操作的原子性—— 而 ++/-- 本质是 “读 - 改 - 写” 三步非原子操作，多线程下的指令交错（CPU 调度切换）会导致结果错误，即便可见性得到保证也无济于事。
    用具体场景拆解一下为什么会这样：
    假设变量 x 被 volatile 修饰，初始值为 0，线程 A 执行 x++，线程 B 执行 x--，底层步骤如下：
    步骤 1：线程 A 获取 CPU 执行权，开始执行x++
            ① 线程 A 从主内存（或共享缓存）读取 x=0 到自己的工作内存（CPU 缓存）；
            ② 线程 A 还没来得及执行 “+1”，CPU 调度切换，线程 B 获得执行权。
    步骤 2：线程 B 执行x--
            ① 线程 B 从主内存读取 x=0（此时线程 A 的修改还没发生，所以读到 0）；
            ② 线程 B 执行 “-1”，得到 x=-1；
            ③ 线程 B 将 x=-1 写回主内存（因为 volatile 保证可见性，此时主内存的 x 已经是 -1，其他线程理论上能看到）；
            ④ 线程 B 执行完毕，CPU 调度切换回线程 A。
    步骤 3：线程 A 继续执行未完成的x++
            ① 线程 A 此时使用的还是步骤 1 中读取的旧值 0（因为它的 “读” 操作已经完成，后续的 “改” 和 “写” 不会再重新读）；
            ② 线程 A 执行 “+1”，得到 x=1；
            ③ 线程 A 将 x=1 写回主内存（覆盖了线程 B 写入的 -1）。
    最终结果：
    原本预期的结果是 0（+1 和 -1 抵消），但实际结果是 1—— 这就是指令交错导致的错误。
    关键原因：volatile 管不了 “操作的拆分与交错”
    volatile 能保证：线程 B 写回的 -1 对线程 A 是 “可见的”，但线程 A 的 “读” 操作已经提前完成，后续不会再重新读取主内存的最新值，而是基于旧值继续计算。
    核心问题在于：x++ 和 x-- 是多步骤操作（读→改→写），volatile 无法将这三步 “绑定” 为一个不可分割的原子操作，CPU 调度可以在任意步骤间切换线程，导致交错。
    总结：
    volatile 的作用是 “让修改及时被看到”，但解决不了 “多线程同时操作同一变量时的步骤交错”。要解决 ++/-- 这类操作的并发问题，必须保证操作的原子性 —— 比如用 synchronized 锁、AtomicInteger 原子类（基于 CAS 指令）等，它们能将 “读 - 改 - 写” 三步绑定为一个不可分割的操作，从根本上避免指令交错。*/





//    print方法中使用了synchronized加锁，所以在循环中不断打印某个值也能实现值的可见性，尽管这个值没有被volatile修饰。

}
