package com.zhh.handsome.Demo4;

public class join原理2 {
    //太牛逼了
    //还是编程有意思，不会欺骗我，对就是对，错就是错，唉。。。。。

    /*先明确一个前提：join()方法的本质
    join()是Thread类的同步方法（被synchronized修饰），源码简化后大概是这样：
    java
            运行
    public class Thread {
        // join()方法的核心逻辑（简化版）
        public final synchronized void join() throws InterruptedException {
            while (this.isAlive()) {  // this指的是调用join()的线程对象（即B线程）
                this.wait();  // 调用wait()的是当前执行join()的线程（即A线程）
            }
        }
    }
    关键步骤：A 线程调用 B.join () 的全过程
    假设现在有两个线程：
    线程 A：主线程（或任意线程）
    线程 B：被 A 等待的线程（A 会调用 B.join ()）
    整个过程如下：
    步骤 1：A 线程准备执行 B.join ()
    A 线程要进入 B 的join()方法，而join()是同步方法（synchronized）。根据 Java 语法，进入同步方法必须先获取该方法所属对象的锁。
    这里，join()是 B 线程对象的方法（B.join()），所以锁对象是B 线程实例本身。→ A 线程会先尝试获取 B 对象的锁。
    步骤 2：A 线程获取到 B 的锁，进入 join () 方法
    假设 A 成功获取到 B 的锁（如果此时没有其他线程竞争 B 的锁），A 进入join()方法内部，执行循环判断：while (B.isAlive())（判断 B 是否还在运行）。
    此时：
    A 线程持有 B 对象的锁
    B 线程可能还在正常运行（和锁无关，B 的执行不需要获取自己的锁，除非 B 自己的代码里有同步逻辑）
    步骤 3：A 线程调用 B.wait ()，释放锁并阻塞
    如果 B 还在运行（isAlive()=true），A 会执行B.wait()。这里的关键是：
    调用 wait () 的是 A 线程（因为现在是 A 在执行 join () 方法）
    wait()的调用者是 B 对象（B.wait()），所以 A 线程会释放 B 对象的锁，并进入 B 对象的 "等待队列" 中阻塞。
    此时：
    A 线程：释放了 B 的锁，进入阻塞状态（不再执行任何代码）
    B 线程：继续运行（不受影响，因为它不需要获取自己的锁）
    B 对象的锁：被释放，其他线程可以获取（但通常没人会竞争，因为锁对象是 B 线程实例本身）
    步骤 4：B 线程执行完毕，JVM 自动唤醒 A
    当 B 线程执行完自己的所有代码后，JVM 会做一件特殊的事：自动调用 B 对象的notifyAll()方法（这是 JVM 的内部机制，不需要我们写代码）。
    这个notifyAll()会唤醒所有等待在 B 对象上的线程 —— 也就是 A 线程。
    步骤 5：A 线程被唤醒，重新获取锁并继续执行
    A 线程被唤醒后，会重新尝试获取 B 对象的锁（因为它之前在synchronized方法里被阻塞，需要重新获得锁才能继续执行）。
    获取锁后，A 会再次进入while (B.isAlive())判断：此时 B 已经执行完毕（isAlive()=false），循环结束，join()方法执行完毕。
            → A 线程继续执行自己后续的代码。
    关键误解纠正
    你提到 “刚一执行方法就把锁释放了”，这个理解有偏差：
    不是 “执行 join () 方法就释放锁”，而是A 线程在 join () 方法内部调用了 B.wait () 之后，才会释放锁。
    释放锁的是 A 线程，而不是 B 线程。B 线程自始至终不需要获取自己的锁（除非 B 自己的代码里有同步逻辑）。
    锁对象自始至终是B 线程实例本身，A 线程通过获取 / 释放这个锁来实现 “等待 B 执行完毕”。
    一句话总结
A调用B.join()的本质是：A 线程先拿到 B 的锁，然后主动通过 B.wait () 释放锁并阻塞，直到 B 执行完后被 JVM 唤醒，最后 A 重新拿锁继续执行。整个过程中，B 线程的执行和它自己的锁无关，锁只是 A 用来 “挂起自己等待 B” 的工具。*/







}
