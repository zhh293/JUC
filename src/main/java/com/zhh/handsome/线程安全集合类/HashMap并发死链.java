// package com.zhh.handsome.线程安全集合类;

// import java.util.HashMap;

// public class HashMap并发死链 {

// HashMap 的「并发死链」是 JDK 1.7 及之前版本中，多线程并发操作 HashMap 时可能出现的一种严重问题 ——
// 由于链表节点的引用形成环形（闭环），导致后续对 HashMap 执行 get 等操作时陷入无限循环，最终造成 CPU 占用率飙升至 100%。
// 要理解这个问题，我们需要先明确两个前提：
// 前提 1：JDK 1.7 HashMap 的底层结构
// JDK 1.7 中，HashMap 底层是「数组 + 链表」的结构：
// 数组（Entry[] table）是主体，每个元素是一个链表的头节点。
// 当多个 key 计算出的哈希值相同时（哈希冲突），会通过「链表」将这些 key 对应的节点串起来（头插法：新节点插入链表头部，而非尾部）。
// 前提 2：HashMap 的扩容机制
// 当 HashMap 中元素数量超过「阈值」（容量 × 负载因子，默认容量 16，负载因子 0.75，阈值 12）时，会触发扩容：
// 创建一个新的、容量更大的数组（默认扩容为原来的 2 倍）。
// 将旧数组中的所有节点重新哈希（rehash）到新数组中（根据新容量重新计算索引位置）。
// 用新数组替换旧数组。
// 扩容的核心是「迁移节点」：遍历旧数组的每个链表，将节点逐个迁移到新数组的对应位置。
// 并发死链的形成过程
// 多线程并发执行 put 操作时，可能同时触发扩容。由于 JDK 1.7 的 HashMap
// 没有任何线程安全措施，多个线程对链表的迁移操作可能相互干扰，最终导致链表节点的引用形成环形（死链）。
// 我们用一个简化的例子分步说明：
// 场景假设
// 旧数组中有一个链表：A → B（A 是头节点，A 的 next 指向 B，B 的 next 为 null）。
// 线程 1 和线程 2 同时对 HashMap 执行 put 操作，均触发扩容，且同时迁移这个链表。
// 步骤 1：线程 1 开始迁移，暂停在中途
// 线程 1 遍历旧链表，准备将 A、B 迁移到新数组：
// 取出头节点 A，记录 A 的 next 是 B（next = A.next → B）。
// 计算 A 在新数组中的位置，将 A 插入新链表（头插法）。此时线程 1 的临时状态：A.next 暂时为 null（等待后续处理 B）。
// 线程 1 突然被挂起（CPU 时间片切换），暂停在处理 B 之前。
// 步骤 2：线程 2 完成迁移，修改了节点引用
// 线程 2 继续处理同一个链表：
// 取出头节点 A，发现 A 的 next 是 B（此时线程 1 还没修改 A 的引用）。
// 先迁移 B：计算 B 在新数组的位置，将 B 插入新链表（头插法），此时 B 的 next 为 null。
// 再迁移 A：计算 A 在新数组的位置（恰好和 B 相同），将 A 以头插法插入 B 所在的链表。此时 A 的 next 指向 B（A.next =
// B），链表变为 A → B（和旧链表顺序相同）。
// 线程 2 完成迁移，新链表状态：A.next = B，B.next = null。
// 步骤 3：线程 1 恢复执行，形成死链
// 线程 1 从暂停处继续执行（它不知道线程 2 已经修改了节点引用）：
// 线程 1 之前记录的 next 是 B，现在开始处理 B。
// 计算 B 在新数组的位置（和 A 相同），将 B 以头插法插入新链表。此时 B 的 next 会指向当前新链表的头节点（也就是线程 2 已经插入的
// A），即 B.next = A。
// 线程 1 继续处理后续节点（但 B 的 next 现在是 A，而非 null），遍历会回到 A，形成闭环：A.next = B，B.next = A。
// 最终结果
// 新链表中 A 和 B 相互引用，形成「死链」。当后续执行 get 操作查询该链表中的元素时，会陷入无限循环（永远遍历不完这个环），导致 CPU
// 占用率瞬间飙升至 100%，程序卡死。
// 为什么 JDK 1.8 不会出现死链？
// JDK 1.8 对 HashMap 的扩容机制做了两点关键优化，避免了死链：
// 尾插法替代头插法：迁移节点时，新节点插入链表尾部（而非头部），节点的顺序和旧链表一致，减少了引用反转的可能性。
// 迁移逻辑调整：扩容时，每个节点的新位置可以通过「旧索引」和「旧索引 +
// 旧容量」快速计算（无需重新哈希），且迁移过程中不会出现多线程交叉修改导致的引用闭环。
// 但注意：JDK 1.8 的 HashMap 仍然不是线程安全的（并发操作可能导致数据丢失、值覆盖等问题），只是解决了死链问题。
// 总结
// 「并发死链」是 JDK 1.7 及之前 HashMap 在多线程扩容时，因头插法和无同步措施，导致链表节点形成环形引用的问题。
// 后果：get 操作陷入无限循环，CPU 飙升。
// 解决方案：并发场景下严禁使用 HashMap，改用线程安全的 ConcurrentHashMap；或升级到 JDK 1.8+
// 避免死链（但仍需注意其他线程安全问题）。

// }

// 具体实例描述一下

// 我们用一个「具体场景 + 画图」的方式拆解，保证你能看懂。
// 场景设定
// 假设我们用的是 JDK 1.7 的 HashMap，现在有两个线程（线程 1、线程 2）同时往里面放数据，触发了扩容，最终导致死链。
// 前提细节：
// HashMap 初始容量是 4（数组长度为 4），负载因子 0.75，所以「阈值」是 4*0.75=3（当元素数超过 3 就会扩容）。
// 现在已经有 3 个元素，再插入第 4 个元素时，会触发扩容（容量变为原来的 2 倍，即 8）。
// 假设扩容前，数组索引 3 的位置有一个链表：A → B（A 是头节点，A 的next指向 B；B 的next是null）。
// 关键：JDK 1.7 扩容用「头插法」
// 迁移节点时，新节点会插在新链表的头部（而不是尾部）。比如旧链表是A→B，迁移后新链表会变成B→A（因为 B 先迁移，A 再插在 B
// 前面）。这个「头插法」是死链的根源。
// 分步拆解：两个线程如何搞出死链？
// 步骤 1：扩容前的状态
// 旧数组（长度 4）的索引 3 位置，链表是：A.next = B，B.next = null（可以理解为：A 指向 B，B 指向空）
// 此时线程 1 和线程 2 同时执行put，都发现元素数超过阈值，同时触发扩容（两个线程都要把旧数组的节点迁移到新数组）。
// 步骤 2：线程 1 先动手，处理到一半被暂停
// 线程 1 的任务：把旧数组索引 3 的A→B迁移到新数组（长度 8）。
// 线程 1 先拿到头节点 A，记录 A 的下一个节点是 B（next = A.next → B）。
// 计算 A 在新数组的位置（假设是索引 7），把 A 插入新数组索引 7 的头部（此时新数组索引 7 只有 A，且 A
// 的next暂时设为null，因为还没处理 B）。
// 关键时刻：线程 1 突然被 CPU 暂停（比如时间片用完），停在「准备处理 B」这一步。
// 此时线程 1 的临时状态：
// 记住了next = B（接下来要处理 B）
// 新数组索引 7 的链表：A.next = null（A 暂时指向空）
// 步骤 3：线程 2 接着处理，完成了迁移
// 线程 2 不知道线程 1 的存在，继续处理旧数组索引 3 的A→B：
// 线程 2 拿到头节点 A，发现 A 的next是 B（此时线程 1 还没修改 A 的指向）。
// 线程 2 先处理 B：
// 计算 B 在新数组的位置（也是索引 7）。
// 用头插法把 B 插入新数组索引 7：此时新数组索引 7 只有 B，B.next = null。
// 线程 2 再处理 A：
// 计算 A 在新数组的位置（索引 7）。
// 用头插法把 A 插入新数组索引 7（插在 B 前面）：此时A.next = B（A 指向 B），B.next = null。
// 线程 2 处理完后，新数组索引 7 的链表是：A → B（A 指向 B，B 指向空）
// 步骤 4：线程 1 恢复运行，亲手制造死链
// 线程 1 从暂停处继续运行（它只记得自己之前的状态，不知道线程 2 已经改过 A 和 B 的指向）：
// 线程 1 要处理之前记录的next = B。
// 计算 B 在新数组的位置（索引 7），准备用头插法插入 B。
// 此时新数组索引 7 的头节点是 A（线程 2 插的）。
// 头插法规则：新节点 B 要插在当前头节点 A 的前面，所以B.next = A（B 指向 A）。
// 线程 1 以为自己处理完了，此时新数组索引 7 的链表变成：
// B → A（B 指向 A），而线程 2 之前已经让A.next = B（A 指向 B）。
// 最终结果：形成闭环（死链）
// 现在新数组索引 7 的链表关系是：A.next = B 并且 B.next = A
// 就像两个人面对面拉手，A 说 “我指向 B”，B 说 “我指向 A”，形成了一个环！
// 为什么会卡死？
// 当后续有线程执行get操作，查询的 key 恰好落在索引 7 的这个链表时，会开始遍历：A → B → A → B → ... 永远循环下去，停不下来。
// 这会导致该线程占用 CPU 不放，最终 CPU 使用率飙升到 100%，程序卡死。
// 一句话总结
// JDK 1.7 的 HashMap
// 在多线程扩容时，因为用「头插法」迁移节点，加上没有锁保护，两个线程会互相打乱对方的节点指向，最终让链表变成一个环，导致遍历陷入无限循环。
// （JDK 1.8 改用「尾插法」，节点迁移时顺序和旧链表一致，就不会出现这种死链了，但 HashMap 本身依然线程不安全，并发场景还是要用
// ConcurrentHashMap。）