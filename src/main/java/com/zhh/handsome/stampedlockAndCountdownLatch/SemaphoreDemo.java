// Semaphore（信号量）是 Java 并发包（java.util.concurrent）中核心的「限流工具类」，作用非常明确 ——控制同时访问共享资源的线程数量，避免因线程过多导致系统过载。
// 下面延续「生活例子→核心定义→核心方法→底层原理→实战案例→优缺点→常见误区→与其他工具类对比」的逻辑，用最通俗的语言 + 完整代码，让你彻底搞懂 Semaphore 的「是什么、怎么用、为什么这么设计」。
// 一、先看生活例子：Semaphore 到底解决什么问题？
// 场景 1：停车场限流
// 停车场有 5 个车位（共享资源），车辆（线程）要进入停车场，必须先占一个车位；
// 车位满了（5 个都被占），后续车辆只能排队等待；
// 有车辆离开（释放车位），排队的车辆才能依次进入。
// 这里的「车位数量 5」就是 Semaphore 的「许可数」，「占车位」是 acquire()（获取许可），「放车位」是 release()（释放许可）。
// 场景 2：秒杀系统接口限流
// 秒杀接口最多允许 10 个线程同时访问（避免数据库被打崩）；
// 超过 10 个线程的请求，要么排队等待，要么直接返回 “系统繁忙”；
// 每个线程处理完请求后，释放 “访问许可”，让下一个线程进来。




// 场景 3：数据库连接池限流
// 连接池有 8 个数据库连接（共享资源）；
// 最多 8 个线程同时获取连接操作数据库；
// 线程用完连接后归还（释放许可），其他线程才能获取。
// 核心痛点：共享资源有限，需要限制并发访问的线程数—— Semaphore 就是专门解决这个 “限流” 问题的，本质是「通过许可数控制线程并发量」。



// Semaphore（翻译：“信号量”）：
// 本质是一个「可动态调整许可数的计数器 + 等待 / 唤醒机制」；
// 初始化时指定「最大许可数」（比如 5 个车位 = 5 个许可）；
// 线程要访问共享资源，必须先调用 acquire() 「获取 1 个许可」（计数器减 1）；
// 线程用完资源后，调用 release() 「释放 1 个许可」（计数器加 1）；
// 若计数器为 0（无许可），后续调用 acquire() 的线程会阻塞，直到有其他线程释放许可。
// 关键特性：
// 许可数可动态调整（release(int permits) 可一次释放多个许可，reducePermits(int reduction) 可减少许可）；
// 支持「公平锁」和「非公平锁」（默认非公平，类似 ReentrantLock）；
// 许可只是逻辑上的概念，不绑定具体资源（比如 5 个许可不一定对应 5 个物理资源，只是限制 5 个线程同时访问）。
// 三、核心方法（4 类关键方法，简单好记）
// Semaphore 的方法不多，核心围绕「获取许可」「释放许可」「调整许可数」，每个方法的作用和注意点都讲清楚：
// 方法分类	方法名	作用	调用方	注意点
// 1. 获取许可（阻塞）	void acquire()	获取 1 个许可，无许可则阻塞	要访问资源的线程	可被中断，中断后抛 InterruptedException
// void acquire(int permits)	获取指定数量的许可（比如 2 个）	要访问资源的线程	permits 不能为负，否则抛非法参数异常
// 2. 获取许可（非阻塞 / 超时）	boolean tryAcquire()	尝试获取 1 个许可，立即返回	要访问资源的线程	成功返回 true，失败返回 false（不阻塞）
// boolean tryAcquire(int permits)	尝试获取指定数量的许可，立即返回	要访问资源的线程	成功返回 true，失败返回 false
// boolean tryAcquire(long timeout, TimeUnit unit)	超时获取 1 个许可	要访问资源的线程	超时前拿到许可返回 true，超时返回 false
// boolean tryAcquire(int permits, long timeout, TimeUnit unit)	超时获取指定数量的许可	要访问资源的线程	同上，permits 需≥0
// 3. 释放许可	void release()	释放 1 个许可（计数器加 1）	用完资源的线程	可释放未获取的许可（导致许可数超初始值）
// void release(int permits)	释放指定数量的许可	用完资源的线程	permits 不能为负
// 4. 其他辅助方法	int availablePermits()	获取当前可用的许可数	任意线程	仅作参考，非原子操作（多线程下可能不准）
// int getQueueLength()	获取等待许可的线程数	任意线程	仅作参考
// void reducePermits(int reduction)	减少指定数量的许可（动态限流）	任意线程	reduction 不能为负，只能减少不能增加
// boolean isFair()	判断是否为公平模式	任意线程	true = 公平，false = 非公平
// 方法调用流程示例（停车场场景）
// java
// 运行
// // 1. 初始化 Semaphore：5 个许可（5 个车位），非公平模式（默认）
// Semaphore semaphore = new Semaphore(5);

// // 2. 线程1要进入停车场（获取 1 个许可）
// semaphore.acquire(); // 许可数 5→4，获取成功，线程1进入

// // 3. 线程2~线程5依次获取许可，许可数 4→3→2→1→0
// // 4. 线程6要进入：许可数为0，阻塞等待

// // 5. 线程1离开停车场（释放 1 个许可）
// semaphore.release(); // 许可数 0→1，唤醒等待的线程6

// // 6. 线程6获取许可成功，进入停车场，许可数 1→0











// 四、底层原理（基于 AQS，通俗讲）
// Semaphore 底层依赖 AQS（AbstractQueuedSynchronizer），和 ReentrantLock、CountDownLatch 是 “同门”，核心逻辑用大白话讲：
// AQS 的 state 变量直接作为 Semaphore 的「许可计数器」：
// 初始化 Semaphore(5) → AQS 的 state=5；
// 获取许可 acquire()：
// 本质是 state--（尝试将 state 减 1）；
// 若减完后 state ≥ 0：获取许可成功，线程继续执行；
// 若减完后 state < 0：获取失败，将线程包装成「共享模式」的节点，加入 AQS 等待队列，然后阻塞线程；
// 释放许可 release()：
// 本质是 state++（将 state 加 1）；
// 加完后若 state > 0：说明有许可可用，遍历 AQS 等待队列，唤醒一个（非公平）或所有（公平）等待的线程；
// 被唤醒的线程会再次尝试 state--，成功则获取许可，继续执行；
// 公平 / 非公平模式：
// 公平模式：线程获取许可时，按「等待队列顺序」依次获取（先到先得）；
// 非公平模式：线程获取许可时，先尝试直接抢占（state--），抢占失败再加入队列（默认模式，效率更高）。
// 关键细节：AQS 的「共享模式」—— 多个线程可以同时获取许可（只要 state 足够），比如 Semaphore 许可数为 5，10 个线程同时调用 acquire()，前 5 个线程会同时获取成功，后 5 个阻塞 —— 这和 ReentrantLock（排他锁，只能一个线程获取）完全不同。
// 五、实战案例：秒杀系统接口限流
// 需求：实现一个秒杀接口，限制同时访问的线程数为 3（避免数据库压力过大）：
// 超过 3 个线程的请求，要么排队等待，要么返回 “系统繁忙”；
// 每个线程处理秒杀逻辑（模拟耗时 1 秒）；
// 处理完后释放许可，让下一个线程进来。
// 步骤 1：实现秒杀服务（用 Semaphore 限流）
// java
// 运行
// import java.util.concurrent.Semaphore;

// // 秒杀服务类：限流 3 个并发线程
// class SecKillService {
//     // 1. 初始化 Semaphore：3 个许可（最多 3 个线程同时访问），公平模式（先到先得）
//     private final Semaphore semaphore = new Semaphore(3, true);

//     // 2. 秒杀接口
//     public void secKill(String userId) {
//         boolean acquired = false;
//         try {
//             // 步骤1：尝试获取许可（超时 2 秒，避免死等）
//             acquired = semaphore.tryAcquire(2, java.util.concurrent.TimeUnit.SECONDS);
//             if (!acquired) {
//                 // 超时未获取到许可，返回系统繁忙
//                 System.out.println("用户 " + userId + "：秒杀失败，系统繁忙，请重试！");
//                 return;
//             }

//             // 步骤2：获取许可成功，执行秒杀逻辑（模拟业务耗时 1 秒）
//             System.out.println("用户 " + userId + "：成功进入秒杀队列，开始处理订单...");
//             Thread.sleep(1000); // 模拟数据库操作、库存扣减等

//             // 步骤3：秒杀成功
//             System.out.println("用户 " + userId + "：秒杀成功！");
//         } catch (InterruptedException e) {
//             Thread.currentThread().interrupt();
//             System.out.println("用户 " + userId + "：秒杀被中断，操作失败！");
//         } finally {
//             // 步骤4：释放许可（必须放在 finally，防止业务异常导致许可泄漏）
//             if (acquired) {
//                 semaphore.release();
//                 System.out.println("用户 " + userId + "：释放秒杀许可，当前可用许可数：" + semaphore.availablePermits());
//             }
//         }
//     }
// }
// 步骤 2：测试高并发秒杀（10 个线程同时请求）
// java
// 运行
// public class SemaphoreDemo {
//     public static void main(String[] args) {
//         SecKillService secKillService = new SecKillService();

//         // 启动 10 个线程，模拟 10 个用户同时秒杀
//         for (int i = 1; i <= 10; i++) {
//             String userId = "U" + i;
//             new Thread(() -> {
//                 secKillService.secKill(userId);
//             }, "秒杀线程-" + userId).start();
//         }
//     }
// }
// 运行结果分析（关键日志）
// plaintext
// 用户 U1：成功进入秒杀队列，开始处理订单...
// 用户 U2：成功进入秒杀队列，开始处理订单...
// 用户 U3：成功进入秒杀队列，开始处理订单...
// 用户 U4：秒杀失败，系统繁忙，请重试！ // 前 3 个线程占满许可，U4 超时未获取
// 用户 U5：秒杀失败，系统繁忙，请重试！
// 用户 U1：秒杀成功！
// 用户 U1：释放秒杀许可，当前可用许可数：1
// 用户 U6：成功进入秒杀队列，开始处理订单... // U1 释放许可，U6 获取成功
// 用户 U2：秒杀成功！
// 用户 U2：释放秒杀许可，当前可用许可数：1
// 用户 U7：成功进入秒杀队列，开始处理订单...
// 用户 U3：秒杀成功！
// 用户 U3：释放秒杀许可，当前可用许可数：1
// 用户 U8：成功进入秒杀队列，开始处理订单...
// 用户 U6：秒杀成功！
// 用户 U6：释放秒杀许可，当前可用许可数：1
// 用户 U9：成功进入秒杀队列，开始处理订单...
// 用户 U7：秒杀成功！
// 用户 U7：释放秒杀许可，当前可用许可数：1
// 用户 U10：成功进入秒杀队列，开始处理订单...
// 用户 U8：秒杀成功！
// 用户 U8：释放秒杀许可，当前可用许可数：1
// 用户 U9：秒杀成功！
// 用户 U9：释放秒杀许可，当前可用许可数：1
// 用户 U10：秒杀成功！
// 用户 U10：释放秒杀许可，当前可用许可数：1
// 核心结论：
// 最多 3 个线程同时执行秒杀逻辑（限流生效）；
// 超时未获取许可的线程直接返回 “系统繁忙”，避免用户长时间等待；
// 线程处理完后必须释放许可（finally 中），否则许可会泄漏，后续线程无法获取。
// 六、Semaphore 的常见使用场景
// 除了上面的「接口限流」，Semaphore 还有 3 个典型场景：
// 场景 1：共享资源并发访问控制
// 比如控制同时访问数据库的连接数、同时下载文件的线程数、同时访问分布式锁的线程数 —— 本质是 “有限资源的并发分配”。
// 场景 2：实现生产者 - 消费者模式
// 用 Semaphore 控制「生产者可生产的最大数量」和「消费者可消费的最大数量」：
// 生产者 Semaphore：许可数 = 最大库存（比如 10），生产者生产前获取许可，生产后释放；
// 消费者 Semaphore：许可数 = 0（初始无库存），消费者消费前获取许可，消费后释放；
// 配合 Condition 实现生产和消费的唤醒。
// 场景 3：动态限流（调整许可数）
// 用 reducePermits(int reduction) 动态减少许可数，实现流量削峰：比如系统负载过高时，调用 semaphore.reducePermits(2)，将许可数从 5 减到 3，减少并发线程数；系统负载降低后，可通过 release(2) 恢复许可数（注意：release 会增加许可数，需谨慎使用）。
// 七、优缺点
// 优点：
// 简单易用：核心方法只有 acquire() 和 release()，逻辑清晰，上手快；
// 灵活度高：
// 支持任意数量的许可（1~N），可按需配置；
// 支持公平 / 非公平模式，适配不同场景；
// 支持超时获取，避免死等；
// 可动态调整许可数，实现动态限流；
// 高效：基于 AQS 实现，底层无锁（CAS）操作，性能优异；
// 支持批量操作：可一次获取 / 释放多个许可（比如 acquire(2) 获取 2 个许可）。
// 缺点：
// 需手动释放许可：若线程获取许可后未释放（比如抛出异常未处理），会导致「许可泄漏」，后续线程无法获取，系统逐渐不可用；
// 不支持重入：同一线程不能重复获取同一许可（比如线程已获取 1 个许可，再调用 acquire() 会阻塞）；
// 许可数是逻辑概念：不绑定具体资源，比如许可数为 5，但实际物理资源只有 3 个，可能导致线程获取许可后仍无法访问资源（需额外处理）；
// 公平模式效率低：公平模式下线程需按队列顺序获取许可，会增加线程切换开销，比非公平模式慢。
// 八、常见误区澄清
// 误区 1：release () 必须在 acquire () 之后调用？
// 错！release() 可以在未调用 acquire() 的情况下调用，此时会「凭空增加许可数」：
// java
// 运行
// Semaphore sem = new Semaphore(1);
// sem.release(); // 许可数 1→2（无获取直接释放，许可数超初始值）
// System.out.println(sem.availablePermits()); // 输出 2
// 风险：导致许可数失控，限流失效；
// 原则：release() 必须和 acquire() 成对出现，仅在获取许可后释放。
// 误区 2：acquire (n) 只能获取 1 个许可？
// 错！acquire(int permits) 可以获取多个许可，比如：
// java
// 运行
// Semaphore sem = new Semaphore(5);
// sem.acquire(2); // 一次获取 2 个许可，许可数 5→3
// 适用场景：线程需要同时占用多个资源（比如同时占用 2 个数据库连接）。
// 误区 3：Semaphore 能保证线程安全？
// 不完全对！Semaphore 只保证「许可的获取和释放是线程安全的」，但它保护的共享资源（如数据库、缓存）本身可能线程不安全 —— 需确保资源的操作是线程安全的（比如用锁、原子类）。
// 误区 4：availablePermits () 的返回值是准确的？
// 错！availablePermits() 是「瞬时值」，多线程环境下，可能刚获取到值，就被其他线程修改（比如其他线程调用了 acquire() 或 release()），仅作参考，不能作为判断是否能获取许可的依据。
// 误区 5：非公平模式一定比公平模式好？
// 不一定！
// 非公平模式：效率高，但可能导致某些线程长时间等待（饥饿）；
// 公平模式：效率低，但能保证线程按顺序获取许可，避免饥饿；
// 选择：并发高、允许偶尔饥饿 → 非公平；并发低、要求严格顺序 → 公平。
// 误区 6：Semaphore 是分布式限流工具？
// 错！Semaphore 是「进程内」的限流工具，仅对当前 JVM 内的线程有效；
// 分布式限流（跨多个 JVM 实例）：需用 Redis + Lua、Nginx 限流等方案。
// 九、与其他并发工具类的区别（避免混淆）
// 之前讲过 CountDownLatch、StampedLock，现在用表格对比 Semaphore，明确各自定位：
// 工具类	核心作用	核心特性	适用场景
// Semaphore	控制并发访问的线程数（限流）	许可数可动态调整，支持公平 / 非公平	接口限流、共享资源并发控制
// CountDownLatch	等待多线程完成后，当前线程再继续	计数器不可重置（一次性），基于 AQS 共享锁	主线程等待子线程完成（如合并结果）
// StampedLock	高并发读场景的读写锁优化	支持乐观读，解决写饥饿，不支持重入	高并发读、低并发写（如缓存）
// ReentrantLock	排他锁（同一时间一个线程获取）	支持重入、公平 / 非公平、条件变量	线程安全的代码块、临界区保护
// 一句话区分：
// 要「限流」→ Semaphore；
// 要「等待多线程完成」→ CountDownLatch；
// 要「高并发读优化」→ StampedLock；
// 要「排他锁保护临界区」→ ReentrantLock。
// 十、总结
// Semaphore 的核心是「通过许可数控制并发线程数」，本质是「进程内限流工具」，关键要点：
// 核心流程：初始化许可数 → 线程获取许可 → 访问资源 → 线程释放许可；
// 关键方法：acquire()（获取）、release()（释放）、tryAcquire(timeout)（超时获取）；
// 必须遵守：release() 与 acquire() 成对出现，放在 finally 中，避免许可泄漏；
// 适用场景：接口限流、共享资源并发控制、生产者 - 消费者模式；
// 注意：进程内有效，分布式限流需用其他方案。