package com.zhh.handsome.ParkUnpark;

public class 底层原理 {




   /* 核心比喻：线程的 “暂停卡” 机制
    想象每个线程都随身携带一个 “暂停卡盒子”：
    盒子里只能放0 张或 1 张暂停卡（对应 “许可” 的有无）。
    park()的行为：检查盒子里有没有卡。
    有卡：把卡扔掉（消耗许可），继续往前走（不阻塞）。
    没卡：停下脚步，进入 “等待状态”，直到有人把卡放进盒子里。
    unpark(Thread t)的行为：给线程t的盒子里放一张卡（如果原本没有）。
    如果t正在等待（因park停下）：放卡后，t会立刻捡起卡扔掉，继续往前走。
    如果t没在等待：卡就放在盒子里，等t下次park时直接用。
    底层到底做了什么？
    park和unpark的逻辑由 JVM 实现，最终会调用操作系统的底层接口（比如 Linux 的pthread库、Windows 的Kernel32.dll）来控制线程状态。具体分三步：
            1. 线程的 “许可” 存储在哪里？
    每个线程在 JVM 内部都有一个对应的 “线程控制块”（类似线程的 “身份证 + 状态记录”），里面有一个专门的变量（比如叫_permit）用来记录 “许可” 状态：
    _permit = 0：无许可（盒子空）。
    _permit = 1：有许可（盒子里有卡）。
            2. 当调用LockSupport.park()时：
    JVM 会做两件事：
    第一步：检查许可查看当前线程的_permit变量：
    如果是 1（有卡）：直接把_permit设为 0（扔掉卡），方法返回，线程继续运行。
    如果是 0（没卡）：进入第二步。
    第二步：让线程 “休眠”JVM 会调用操作系统的接口（比如 Linux 的sched_yield或pthread_cond_wait），告诉操作系统：“这个线程暂时不用 CPU 了，让它进入等待状态吧”。此时线程会从 “运行中” 切换到 “阻塞态”，不再参与 CPU 调度，相当于 “暂停” 了。
            3. 当调用LockSupport.unpark(Thread t)时：
    JVM 会做两件事：
    第一步：补充许可查看线程t的_permit变量：
    如果是 0（没卡）：把_permit设为 1（放一张卡）。
    如果是 1（已有卡）：啥也不做（因为最多只能有 1 张卡）。
    第二步：唤醒线程（如果需要）检查线程t是否处于 “因 park 而阻塞” 的状态：
    如果是：JVM 调用操作系统接口（比如 Linux 的pthread_cond_signal），告诉操作系统：“把t唤醒吧，让它继续跑”。此时t会从 “阻塞态” 回到 “就绪态”，重新等待 CPU 调度。
    如果不是：啥也不做（卡已经放在盒子里，等t下次park时用）。
    为什么unpark可以在park之前调用？
    这是因为 “许可” 是可以提前存储的。
    比如先调用unpark(t)：t的_permit变成 1（卡已放好）。
    后续t调用park()时，发现有卡（_permit=1），直接消耗掉（设为 0），不会阻塞。
    这就像你提前给朋友塞了一张电影票，朋友到了电影院直接用票入场，不用排队。而wait/notify就像 “现场发票”，如果朋友还没到（没调用wait），你发的票就作废了（信号丢失）。
    中断为什么能唤醒park？
    线程的 “中断状态” 也是线程控制块里的一个标记（比如_interrupted）。当线程因park阻塞时，如果其他线程调用了thread.interrupt()：
    JVM 会把线程的_interrupted标记设为true。
    同时强制唤醒线程（和unpark的唤醒逻辑类似），让park()方法返回。
    但park不会像wait那样抛异常，只是让线程继续运行，需要我们自己通过Thread.interrupted()检查中断状态。
    总结：底层核心逻辑
    park和unpark的本质是：JVM 通过给每个线程维护一个 “许可变量”，配合操作系统的线程阻塞 / 唤醒接口，实现了 “按需暂停” 和 “精准唤醒” 的功能。
    许可变量控制是否需要阻塞；
    操作系统接口负责实际的线程状态切换（运行→阻塞，阻塞→就绪）。
    这种设计比synchronized的wait/notify更灵活，因为它摆脱了同步块的束缚，还能提前 “储备唤醒信号”。*/





}
