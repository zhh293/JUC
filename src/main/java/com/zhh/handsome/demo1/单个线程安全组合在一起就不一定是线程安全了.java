package com.zhh.handsome.demo1;

public class 单个线程安全组合在一起就不一定是线程安全了 {
    /*要理解这段代码的线程不安全问题，需从 **“复合操作的原子性”** 角度分析：
            1. Hashtable 单个方法的线程安全性
    Hashtable的get()和put()方法本身是线程安全的（内部通过synchronized同步，保证单个方法调用时的原子性）。
            2. 问题：“检查 - 然后 - 操作” 的复合操作非原子
    代码逻辑是：

    java
if (table.get("key") == null) { // 步骤1：检查
        table.put("key", value);    // 步骤2：操作
    }

    这是一个 **“检查（get）→ 然后（条件满足）→ 操作（put）”的复合操作 **。

    虽然get()和put()各自线程安全，但 **“步骤 1 + 步骤 2” 这两个操作的组合不是原子的 **—— 线程在执行完get()后，可能被其他线程打断，导致多线程同时 “通过检查”，进而重复执行put()。
            3. 时序图的具体演示
    结合时序图，线程执行顺序可能是：

    线程 1 执行 table.get("key") == null → 结果为null（通过检查）。
    线程 1 被暂停，线程 2 开始执行。
    线程 2 执行 table.get("key") == null → 结果也为null（通过检查）。
    线程 2 执行 table.put("key", v2) → 向table中放入v2。
    线程 2 执行完毕，线程 1 恢复执行。
    线程 1 执行 table.put("key", v1) → 向table中放入v1（覆盖线程 2 放入的v2）。
            4. 最终结果：逻辑错误
    原本期望的是：只有当"key"不存在时，才放入值（类似 “单例初始化” 或 “防止重复插入” 的逻辑）。但由于多线程同时 “钻了检查和操作之间的空子”，导致两个线程都执行了put，最终"key"的值被线程 1 的v1覆盖，破坏了 “仅初始化一次” 的逻辑。
    结论
    线程不安全的核心原因是：“检查（get）+ 操作（put）” 的复合逻辑没有被原子性保护。即使容器（Hashtable）的单个方法是线程安全的，也无法保证 “多步操作组合” 的线程安全。
*/
}
