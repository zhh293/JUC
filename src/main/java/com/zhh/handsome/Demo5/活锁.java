package com.zhh.handsome.Demo5;

public class 活锁 {

   /* 活锁可以理解为 “忙死了，但啥也没干成” 的状态 —— 简单说，就是多个线程（或进程）为了 “互相谦让”，不断地主动释放资源、调整自己的行为，但因为节奏同步，反而陷入了无限循环的 “内耗”，永远无法完成任务。
    举个生活中的例子：两个人在一条窄路上迎面走来，都想给对方让路。
    甲往右躲，乙也同时往右躲，结果还是撞上；
    两人赶紧都往左躲，又撞在一起；
    然后又同时往右…… 一直重复这个过程，谁也过不去。
    这就是活锁：双方都在 “积极行动”（不断调整位置），但因为行动节奏完全同步，反而永远卡在原地，没任何进展。
    对应到计算机里：比如两个线程 A 和 B，都需要同时获取资源 1 和资源 2 才能工作。
    A 先拿到资源 1，发现资源 2 被 B 拿着，就主动释放资源 1，想等 B 用完再试；
    同时，B 拿到资源 2，发现资源 1 被 A 拿着（其实 A 刚释放），也主动释放资源 2，想等 A 用完再试；
    接着，A 和 B 又同时去拿资源 1 和资源 2，再次重复上面的过程……
    结果就是：两个线程一直在 “释放资源→重试→再释放→再重试”，看似一直在运行（没卡住），但永远拿不到需要的所有资源，任务根本无法推进。
    活锁和死锁的区别：
    死锁是 “僵持不动”：每个线程都握着资源，等着别人释放，彼此僵住，完全不行动；
    活锁是 “白忙活”：线程一直在主动释放、重试，有行动，但因为互相干扰，永远没结果。
    简单说，活锁就是 “好心办坏事”—— 为了避免冲突而主动调整，却因为调整节奏同步，反而陷入了无效的循环。*/



}
