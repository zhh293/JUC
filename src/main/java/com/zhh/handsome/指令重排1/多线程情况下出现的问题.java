package com.zhh.handsome.指令重排1;

public class 多线程情况下出现的问题 {




    /*指令重排在多线程情况下会出现什么问题呀
    用 “两个厨师合作备餐” 的类比，就能秒懂多线程下指令重排的坑 —— 单线程时你（一个厨师）重排步骤没问题，但多线程（两个厨师）共享食材时，一方的重排可能让另一方拿到 “半成品”，导致最终出餐出错。
    核心结论
    多线程下，指令重排会打破线程间的 “执行顺序预期”。因为 CPU 只保证 “单个线程内” 重排后结果正确，却不考虑 “线程间的共享数据依赖”，最终可能导致线程读到错误的数据，出现逻辑混乱。
    用 “备餐案例” 看具体问题
    假设场景：两个厨师合作做 “番茄炒蛋”，共享两个关键食材状态，需要按逻辑顺序配合：
    厨师 A（线程 A） 的任务：1. 切好番茄（tomato = 1，表示番茄就绪）；2. 喊一声 “番茄好了”（ready = true，通知厨师 B）。
    厨师 B（线程 B） 的任务：1. 一直等 “番茄好了”（判断ready == true）；2. 一旦听到，就用番茄炒蛋（读取tomato的值）。
    按正常逻辑，A 必须先做 1 再做 2，B 才能拿到 “切好的番茄”（tomato=1）。但指令重排会打破这个预期。
            1. 问题 1：线程间 “执行顺序错乱”
    CPU 对厨师 A 的步骤做了重排：因为 “切番茄” 和 “喊口号” 在 A 的单线程里没有直接数据依赖（A 自己不用等番茄切好再喊），所以 A 可能先喊 “番茄好了”（ready=true），再慢慢切番茄（tomato=1）。
    此时厨师 B 的动作：
    刚听到 “番茄好了”（ready=true），立刻去拿番茄；
    但 A 还没切完（tomato还是初始值 0），B 拿到 “没切的番茄”，根本没法炒蛋，最终做出 “黑暗料理”（程序逻辑错误）。
            2. 问题 2：共享变量 “可见性失效”
    就算 A 没重排，CPU 的 “缓存机制” 也可能和重排叠加出问题。比如：
    A 确实先切了番茄（tomato=1），但这个值还存在 A 的 “私人砧板”（CPU 缓存）里，没同步到 “公共食材台”（主内存）；
    接着 A 喊了 “番茄好了”（ready=true），B 看到后去公共台拿，却发现tomato还是 0（没同步过来），同样出错。
    这种情况本质是：重排可能让 “变量更新” 和 “通知同步” 的顺序错乱，导致线程间看不到最新数据。
            3. 问题 3：破坏 “逻辑依赖”
    有些线程间的依赖是 “隐性逻辑依赖”，而非 CPU 能识别的 “数据依赖”。比如：
    线程 A 负责 “初始化配置文件”（步骤 1），再 “标记配置可用”（步骤 2）；
    线程 B 负责 “读取可用的配置”（必须等步骤 2 后）。
    CPU 会认为 A 的步骤 1 和 2 没有直接数据依赖（都是写操作），可能重排为 “先标记可用，再初始化配置”。此时 B 读到的是 “未初始化的配置”，直接导致程序崩溃。
    问题本质：CPU 的 “单线程视角”
    CPU 设计指令重排时，只关注 “单个线程内的指令是否有数据依赖”，完全不考虑 “其他线程会读取这些变量”。就像厨师 A 只关心自己的步骤顺不顺畅，没意识到自己的动作会影响厨师 B 的判断 —— 这就是多线程下重排出问题的根源。*/




    

    /// 代码演示

    /*当然可以！用 Java 代码举一个经典的 “指令重排导致多线程逻辑错误” 的例子 —— 这个例子本身很简单，但由于 CPU 可能对无依赖的指令重排，会出现 “看似不可能” 的错误结果。
    代码场景
    两个线程共享两个变量：data（业务数据）和ready（标记数据是否就绪）。
    线程 A 的任务：先给data赋值（比如1），再把ready设为true（通知线程 B “数据好了”）。
    线程 B 的任务：循环等待ready变为true，一旦满足就读取data的值并打印。
    预期逻辑：线程 B 应该只能读到data=1（因为 A 先赋值再通知）。实际可能：由于指令重排，线程 B 可能读到data=0（初始值），这就是错误。
    代码示例
            java
    运行
    public class ReorderExample {
        // 共享变量：数据和就绪标记
        private static int data = 0;
        private static boolean ready = false;

        public static void main(String[] args) throws InterruptedException {
            // 循环多次运行，增加指令重排触发的概率（重排不是每次都发生）
            for (int i = 0; i < 100000; i++) {
                // 每次循环重置变量（避免上次运行影响）
                data = 0;
                ready = false;

                // 线程A：设置数据 -> 标记就绪
                Thread threadA = new Thread(() -> {
                    data = 1;          // 步骤1：给数据赋值
                    ready = true;      // 步骤2：标记数据就绪
                });

                // 线程B：等待就绪 -> 读取数据
                Thread threadB = new Thread(() -> {
                    if (ready) {       // 步骤3：检查是否就绪
                        // 如果ready为true，理论上data应该是1
                        System.out.println("读取到data：" + data);
                    }
                });

                // 启动线程
                threadA.start();
                threadB.start();
                // 等待两个线程执行完，再进行下一次循环
                threadA.join();
                threadB.join();
            }
        }
    }
    为什么会出错？
    正常情况下，线程 A 的步骤 1（data=1）和步骤 2（ready=true）是顺序执行的，线程 B 会读到data=1。
    但 CPU 可能对线程 A 的指令重排：因为data=1和ready=true这两条指令在单线程内没有数据依赖（ready的值不依赖data，data的值也不依赖ready），CPU 为了提高效率，可能先执行步骤 2（ready=true），再执行步骤 1（data=1）。
    此时线程 B 的执行顺序可能变成：
    线程 A 先执行ready=true（步骤 2），还没执行data=1（步骤 1）；
    线程 B 刚好检测到ready=true，立刻读取data，但此时data还是初始值0，最终打印出读取到data：0—— 这与预期逻辑完全矛盾。*/

}
